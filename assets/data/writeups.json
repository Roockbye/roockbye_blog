[
  {
    "id": "cognitive-reminder-call",
    "title": "Cognitive Reminder Call",
    "category": "crypto",
    "difficulty": "medium",
    "summary": "Challenge Crypto",
    "content": "<p>The server seems to be forgetful :( </p>\n<p>Can you help it remember?</p>\n\n<p>Files provided :</p>\n<ul><li>server.py</li>\n<li>Pipfile.lock </li>\n<li>Pipfile</li>\n<li>Dockerfile</li>\n</ul>\n<p>We’re given a network service. When we connect, we see something like:</p>\n\n<pre><code>Here is the flag: &lt;big hex&gt;\n<p>Note: This message was sent over an authenticated channel. Its tag is &lt;tag1&gt; with nonce &lt;nonce1&gt;.</p>\n<p>I have forgotten my key :(</p>\n<p>But here are 4 congnitive reminders of my key:</p>\n<p>Note: This message was sent over an authenticated channel. Its tag is &lt;tag2&gt; with nonce &lt;nonce2&gt;.</p>\n<p>[crc0, crc1, crc2, crc3]</p>\n<p>Note: This message was sent over an authenticated channel. Its tag is &lt;tag3&gt; with nonce &lt;nonce3&gt;.</p>\n<p>Please remind me of my key:</p>\n<p>Part 1 (hex):</code></pre></p>\n\n<h2>1. What the server actually does</h2>\n\n<p>Internally, the server:</p>\n\n<ol><li>Generates 4 random 16-byte chunks:</li>\n</ul>\n<p> <pre><code>enc<em>key</em>parts = [os.urandom(16) for _ in range(4)]</code></pre></p>\n\n<ol><li>Derives an AES key from them:</li>\n</ul>\n<p> <pre><code>key = SHA256(enc<em>key</em>parts[0] + enc<em>key</em>parts[1] +</p>\n<p>\t            enc<em>key</em>parts[2] + enc<em>key</em>parts[3])</code></pre></p>\n\n<ol><li>Encrypts the flag with AES-256-CBC and sends:</li>\n</ul>\n<pre><code>Here is the flag: &lt;IV || ciphertext in hex&gt;</code></pre>\n\n<ol><li>Uses a secret <code>mac_key</code> and “authenticates” several messages using:</li>\n</ul>\n<pre><code>def mac(key, message):\n<p>\treturn crc32(key + message)   # 32-bit CRC</code></pre></p>\n\n<p>So each “Note: … tag is … with nonce …” is basically:</p>\n\n<pre><code>tag = crc32(mac_key + nonce + message)</code></pre>\n\n<ol><li>Then it “forgets” the real <code>enc<em>key</em>parts</code>, but gives us these <strong>4 CRC32 values</strong>:</li>\n</ul>\n<p>  <pre><code>enc<em>key</em>parts<em>checksums = [crc32(part) for part in enc</em>key_parts]</code></pre></p>\n\n<p>and asks us:</p>\n<ul><li>4 parts, each 16 bytes, in hex</li>\n<li>a nonce (4 bytes in hex)</li>\n<li>a tag = <code>crc32(mac_key + nonce + part1 + part2 + part3 + part4)</code></li>\n</ul>\n<ol><li>If our tag is valid <strong>and</strong> all 4 parts have the correct CRC32, it accepts our “reminder”, recomputes the AES key from <strong>our</strong> parts, and sends:</li>\n</ul>\n<p>    <pre><code>Thanks for reminding me! Here is a reward: &lt;IV || ciphertext’ hex&gt;</code></pre></p>\n\n<p>This new ciphertext is the <em>same plaintext flag</em>, but encrypted with the key derived from <strong>our</strong> 4 parts.</p>\n\n<p>If we can:</p>\n<ul><li>forge a valid MAC, and</li>\n<li>craft 4 parts that match the required CRC32s,</li>\n</ul>\n<p>we can decrypt this second ciphertext and get the flag.</p>\n\n<h2>2. Big picture of the attack</h2>\n\n<p>We want to:</p>\n\n<ol><li><strong>Break the MAC</strong>: <code>crc32(mac_key || message)</code>  </li>\n</ul>→ forge a valid tag for <code>nonce || part1 || part2 || part3 || part4</code> without knowing <code>mac_key</code>.\n\n<ol><li><strong>Forge the 4 key parts</strong>:  </li>\n</ul>For each target CRC <code>ci</code> in the list <code>[c0, c1, c2, c3]</code> we must build a 16-byte block <code>part_i</code> such that:\n\n<pre><code>crc32(part_i) == ci</code></pre>\n\n<ol><li><strong>Get the final ciphertext</strong>, decrypt with <strong>our</strong> AES key and recover the flag.</li>\n</ul>\n<p>Both come from the same fact: <strong>CRC32 is linear and totally not a secure MAC</strong>.</p>\n\n<h2>3. Understanding CRC32 as a linear function</h2>\n\n<p>In Python, <code>binascii.crc32(data, seed)</code> behaves like this:</p>\n\n<pre><code>crc32(data, seed) = A<em>data * seed  XOR  c</em>data</code></pre>\n\n<p>Where:</p>\n<ul><li><code>seed</code> and the result are 32-bit integers</li>\n<li>operations are over GF(2) (bitwise linear algebra)</li>\n<li><code>A_data</code> is a 32×32 binary matrix</li>\n<li><code>c_data</code> is a 32-bit constant</li>\n</ul>\n<p>We don’t need to derive them by hand; we can <em>ask</em> the function by probing different seeds.</p>\n\n<h3>3.1. Recovering the internal MAC state <code>crc32(mac_key)</code></h3>\n\n<p>The MAC is:</p>\n<pre><code>tag = crc32(mac_key + data)</code></pre>\n\n<p>This is equivalent to:</p>\n<pre><code>Ck = crc32(mac_key)\n<p>tag = crc32(data, seed=Ck)</code></pre></p>\n\n<p>And because <code>crc32(data, seed) = A * seed XOR c</code>, for a given <code>data</code> we have:</p>\n<pre><code>tag = A<em>data * Ck XOR c</em>data</code></pre>\n\n<p>That’s a linear equation in 32 bits. If we know:</p>\n<ul><li><code>data</code> (nonce || message)</li>\n<li><code>tag</code> (given by the server)</li>\n</ul>\n<p>we can solve for <code>Ck = crc32(mac_key)</code>.</p>\n\n<p>How do we get <code>A<em>data</code> and <code>c</em>data</code>?</p>\n<ul><li><code>c_data = crc32(data, 0)</code></li>\n<li>For each bit <code>i</code> of the seed:</li>\n</ul><pre><code>s0 = 1 &lt;&lt; i\n<p> sf = crc32(data, s0)</p>\n<p> column<em>i = sf ^ c</em>data   # how this seed bit influences the output</code></pre></p>\n\n<p>Stacking all columns gives us the 32×32 matrix <code>A_data</code>.  </p>\n<p>Then we invert it with Gaussian elimination over GF(2) (a 32×32 bit matrix is small) to recover:</p>\n<pre><code>Ck = A<em>data^{-1} * (tag ^ c</em>data)</code></pre>\n\n<p>Once we have <code>Ck = crc32(mac_key)</code>, we can compute a valid MAC for <strong>any</strong> data <code>M</code>:</p>\n<pre><code>fake_tag = crc32(M, seed=Ck)</code></pre>\n\n<p>Exactly like the server would.</p>\n\n<p>So:</p>\n<ul><li>We use one of the authenticated messages from the server (e.g. the third one with the checksum list).</li>\n<li>We compute <code>Ck</code>.</li>\n<li>Then we can forge a tag for our own <code>(nonce || part1 || part2 || part3 || part4)</code>.</li>\n</ul>\n<h2>4. Building 16-byte blocks with a chosen CRC32</h2>\n\n<p>Now about the “cognitive reminders”:</p>\n\n<p>The server gives us:</p>\n<pre><code>enc<em>key</em>parts_checksums = [c0, c1, c2, c3]</code></pre>\n\n<p>We must produce 4 blocks <code>part_i</code> such that:</p>\n<pre><code>len(part_i) == 16\n<p>crc32(part<em>i) == c</em>i</code></pre></p>\n\n<p>Again, CRC32 is linear, so we can treat this like solving a linear equation.</p>\n<h3>Idea</h3>\n\n<ol><li>Choose a random 12-byte prefix:</li>\n</ul>\n<pre><code>prefix = os.urandom(12)</code></pre>\n\n<ol><li>Let the last 4 bytes be an unknown 32-bit integer <code>x</code> (little-endian).  </li>\n</ul>So the block is <code>prefix || x</code>.\n\n<ol><li>Define:</li>\n</ul>    <pre><code>F(x) = crc32(prefix + x.to_bytes(4, 'little'))</code></pre>\n\n<p>Because CRC32 is linear, <code>F(x)</code> is an affine function:</p>\n<pre><code>F(x) = B * x  XOR  d</code></pre>\n\n<ol><li>Compute:</li>\n<li><code>F0 = F(0)</code> → that’s <code>d</code>.</li>\n<li>For each bit i of x:</li>\n</ul>\t- Let <code>x = (1 << i)</code>\n<p>\t- Compute <code>Fi = F(1 << i)</code></p>\n<p>\t- The difference <code>Fi ^ F0</code> gives you how bit i affects the CRC → column i of matrix <code>B</code>.</p>\n\n<ol><li>Now, to solve for a target CRC <code>target</code>:</li>\n</ul>    <pre><code>F(x) = target\n<p>    → B * x XOR F0 = target</p>\n<p>    → B * x = target XOR F0</p>\n<p>    → x = B^{-1} * (target XOR F0)</code></pre></p>\n<ol><li>Then:</li>\n</ul><pre><code>suffix = x.to_bytes(4, 'little')\n<p>block  = prefix + suffix</code></pre></p>\n<p>And by construction:</p>\n<pre><code>crc32(block) == target</code></pre>\n\n<p>Repeat this 4 times, once for each target CRC in the list → we get 4 valid 16-byte parts.</p>\n\n<h2>5. Putting it all together: the exploit flow</h2>\n\n<p>Here’s the full logic step-by-step.</p>\n<h3>5.1. Connect and read data</h3>\n\n<p>We connect with:</p>\n<pre><code>nc 10.80.8.34 1337</code></pre>\n\n<p>We read:</p>\n<ul><li>The initial encrypted flag + its tag and nonce</li>\n<li>The “forgotten key” message + tag/nonce</li>\n<li>The checksum list <code>[c0, c1, c2, c3]</code> + tag/nonce</li>\n</ul>\n<p>We especially keep:</p>\n<ul><li><code>msg3</code> = the line containing <code>[c0, c1, c2, c3]</code> as plain text</li>\n<li><code>nonce3</code>, <code>tag3</code> = from the note after that</li>\n</ul><h3>5.2. Recover <code>crc32(mac_key)</code></h3>\n\n<p>We treat:</p>\n<pre><code>data3 = nonce3 + msg3.encode()\n<p>tag3  = int(tag3_hex, 16)</code></pre></p>\n\n<p>We call our helper:</p>\n<pre><code>Ck = recover<em>crc32</em>key_state(data3, tag3)</code></pre>\n\n<p>And now <code>Ck</code> is the internal CRC state after the MAC key.  </p>\n<p>We don’t know <code>mac_key</code> itself, but we don’t care; we can MAC like the server does.</p>\n\n<h3>5.3. Build 4 valid key parts</h3>\n\n<p>For each <code>ci</code> in the given list:</p>\n<pre><code>part<em>i = build</em>block<em>for</em>crc(ci)</code></pre>\n\n<p>Where <code>build<em>block</em>for_crc</code> implements the “prefix + 4-byte suffix + linear solve” trick.</p>\n\n<p>We end up with a list:</p>\n<pre><code>parts = [part0, part1, part2, part3]  # each 16 bytes</code></pre>\n\n<p>And we can verify locally:</p>\n<pre><code>for p, c in zip(parts, checksums):\n<p>    assert crc32(p) == c</code></pre></p>\n\n<h3>5.4. Choose our nonce and forge a MAC</h3>\n\n<p>We choose a random 4-byte nonce that we haven’t seen before:</p>\n<pre><code>new_nonce = os.urandom(4)</code></pre>\n\n<p>Build our message:</p>\n<pre><code>message = new_nonce + b\"\".join(parts)</code></pre>\n\n<p>Compute the forged tag:</p>\n<pre><code>fake_tag = crc32(message, seed=Ck)</code></pre>\n\n<p>We keep it as 4 bytes (big-endian or little-endian depending on the server; in our case, big-endian hex).</p>\n\n<h3>5.5. Talk to the server</h3>\n\n<p>The server asks:</p>\n<pre><code>Please remind me of my key:\n<p>Part 1 (hex):</code></pre></p>\n\n<p>We send:</p>\n<pre><code>a96cab226baf6aec2aab327c9d96b8ce\n<p>877434fb953113c148214dd625b83ab7</p>\n<p>5c469566e4e8b6faf05a68aca7c006ca</p>\n<p>f5786f66a44238d235621b94fd42df12</code></pre></p>\n\n<p>(Those were our specific valid parts for that instance.)</p>\n\n<p>Then:</p>\n<pre><code>This is an authenticated channel!\n<p>Please provide your nonce (hex):</code></pre></p>\n\n<p>We send:</p>\n<pre><code>47483567</code></pre>\n\n<p>Then:</p>\n<pre><code>Please provide the tag of the concatenation of the nonce and the 4 parts (hex):</code></pre>\n\n<p>We send:</p>\n<pre><code>c569a991</code></pre>\n\n<p>This tag is exactly:</p>\n<pre><code>crc32(new_nonce + part1 + part2 + part3 + part4, seed=Ck)</code></pre>\n\n<p>So the server accepts it.</p>\n\n<h3>5.6. Get the reward and decrypt</h3>\n\n<p>The server answers:</p>\n<pre><code>Thanks for reminding me! Here is a reward: &lt;reward<em>cipher</em>hex&gt;</code></pre>\n\n<p>We copy <code><reward<em>cipher</em>hex></code> and decrypt locally.</p>\n\n<p>To decrypt:</p>\n<ol><li>Convert hex to bytes.</li>\n<li>Split:</li>\n</ul>    <pre><code>iv = data[:16]\n<p>    ct = data[16:]</code></pre></p>\n<ol><li>Re-derive the AES key exactly as the server does:</li>\n</ul>    <pre><code>hasher = Hash(SHA256())\n<p>    for p in parts:</p>\n<p>        hasher.update(p)</p>\n<p>    key = hasher.finalize()</code></pre></p>\n<ol><li>Decrypt AES-CBC and unpad:</li>\n</ul>    <pre><code>cipher = Cipher(algorithms.AES(key), modes.CBC(iv))\n<p>    decryptor = cipher.decryptor()</p>\n<p>    padded = decryptor.update(ct) + decryptor.finalize()</p>\n    \n<p>    unpadder = PKCS7(128).unpadder()</p>\n<p>    plaintext = unpadder.update(padded) + unpadder.finalize()</code></pre></p>\n\n<p>The result is the flag:</p>\n<pre><code>PP{h4sh3s<em>4r3</em>m0r3<em>th4n</em>ch3cksums::9--CHRRGexlY}</code></pre>\n\n<h2>Why this is insecure ?</h2>\n\n<p> CRC32 is not a cryptographic function. It’s <em>linear</em> and has a very simple algebraic structure.</p>\n\n<ul><li>Using <code>crc32(key || message)</code> as a MAC is <strong>completely broken</strong>:</li>\n</ul>    - You can model it as a matrix multiplication.\n<p>    - With one authenticated message you can recover the internal state after the key.</p>\n<p>    - Then you can forge valid tags for any message, without knowing the key.</p>\n\n<p>On top of that:</p>\n<ul><li>CRC32 is easy to invert on small messages; we can craft data that has any CRC32 we want.</li>\n<li>That’s how we built 16-byte blocks matching the “cognitive reminder” checksums.</li>\n</ul>\n<p>So the whole challenge is basically:</p>\n<p>“Look what happens when you treat a checksum like a cryptographic hash/MAC.”</p>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "crypto",
      "platypwn2025",
      "CRC32",
      "MAC"
    ],
    "hash": "sha512:fb911c5e9347",
    "mitigations": [
      "Review and validate security controls",
      "Implement proper input validation",
      "Enable security monitoring and logging"
    ],
    "date": "2025-12-03T11:11:00Z"
  }
]