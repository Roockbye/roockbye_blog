[
  {
    "id": "cognitive-reminder-call",
    "title": "Cognitive Reminder Call",
    "category": "crypto",
    "difficulty": "medium",
    "summary": "Challenge Crypto",
    "content": "<p>The server seems to be forgetful :(  Can you help it remember?</p>\n<p>Files provided :</p>\n<ul>\n<li>server.py</li>\n<li>Pipfile.lock </li>\n<li>Pipfile</li>\n<li>Dockerfile</li>\n</ul>\n<p>We’re given a network service. When we connect, we see something like:</p>\n<pre><code>Here is the flag: &lt;big hex&gt;\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag1&gt; with nonce &lt;nonce1&gt;.\nI have forgotten my key :(\nBut here are 4 congnitive reminders of my key:\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag2&gt; with nonce &lt;nonce2&gt;.\n[crc0, crc1, crc2, crc3]\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag3&gt; with nonce &lt;nonce3&gt;.\nPlease remind me of my key:\nPart 1 (hex):</code></pre>\n<h2>1. What the server actually does</h2>\n<p>Internally, the server:</p>\n<ol>\n<li>Generates 4 random 16-byte chunks:</li>\n</ol>\n <pre><code>enc_key_parts = [os.urandom(16) for _ in range(4)]</code></pre>\n<ol>\n<li>Derives an AES key from them:</li>\n</ol>\n <pre><code>key = SHA256(enc_key_parts[0] + enc_key_parts[1] +\n\t            enc_key_parts[2] + enc_key_parts[3])</code></pre>\n<ol>\n<li>Encrypts the flag with AES-256-CBC and sends:</li>\n</ol>\n<pre><code>Here is the flag: &lt;IV || ciphertext in hex&gt;</code></pre>\n<ol>\n<li>Uses a secret <code>mac_key</code> and “authenticates” several messages using:</li>\n</ol>\n<pre><code>def mac(key, message):\n\treturn crc32(key + message)   # 32-bit CRC</code></pre>\n<p>So each “Note: … tag is … with nonce …” is basically:</p>\n<pre><code>tag = crc32(mac_key + nonce + message)</code></pre>\n<ol>\n<li>Then it “forgets” the real <code>enc<em>key</em>parts</code>, but gives us these <strong>4 CRC32 values</strong>:</li>\n</ol>\n  <pre><code>enc_key_parts_checksums = [crc32(part) for part in enc_key_parts]</code></pre>\n<p>and asks us:</p>\n<ul>\n<li>4 parts, each 16 bytes, in hex</li>\n<li>a nonce (4 bytes in hex)</li>\n<li>a tag = <code>crc32(mac_key + nonce + part1 + part2 + part3 + part4)</code></li>\n</ul>\n<ol>\n<li>If our tag is valid <strong>and</strong> all 4 parts have the correct CRC32, it accepts our “reminder”, recomputes the AES key from <strong>our</strong> parts, and sends:</li>\n</ol>\n    <pre><code>Thanks for reminding me! Here is a reward: &lt;IV || ciphertext’ hex&gt;</code></pre>\n<p>This new ciphertext is the <em>same plaintext flag</em>, but encrypted with the key derived from <strong>our</strong> 4 parts.</p>\n<p>If we can:</p>\n<ul>\n<li>forge a valid MAC, and</li>\n<li>craft 4 parts that match the required CRC32s,</li>\n</ul>\n<p>we can decrypt this second ciphertext and get the flag.</p>\n<h2>2. Big picture of the attack</h2>\n<p>We want to:</p>\n<ol>\n<li><strong>Break the MAC</strong>: <code>crc32(mac_key || message)</code>  </li>\n<p>→ forge a valid tag for <code>nonce || part1 || part2 || part3 || part4</code> without knowing <code>mac_key</code>.</p>\n</ol>\n<ol>\n<li><strong>Forge the 4 key parts</strong>:  </li>\n<p>For each target CRC <code>ci</code> in the list <code>[c0, c1, c2, c3]</code> we must build a 16-byte block <code>part_i</code> such that:</p>\n</ol>\n<pre><code>crc32(part_i) == ci</code></pre>\n<ol>\n<li><strong>Get the final ciphertext</strong>, decrypt with <strong>our</strong> AES key and recover the flag.</li>\n</ol>\n<p>Both come from the same fact: <strong>CRC32 is linear and totally not a secure MAC</strong>.</p>\n<h2>3. Understanding CRC32 as a linear function</h2>\n<p>In Python, <code>binascii.crc32(data, seed)</code> behaves like this:</p>\n<pre><code>crc32(data, seed) = A_data * seed  XOR  c_data</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>seed</code> and the result are 32-bit integers</li>\n<li>operations are over GF(2) (bitwise linear algebra)</li>\n<li><code>A_data</code> is a 32×32 binary matrix</li>\n<li><code>c_data</code> is a 32-bit constant</li>\n</ul>\n<p>We don’t need to derive them by hand; we can <em>ask</em> the function by probing different seeds.</p>\n<h3>3.1. Recovering the internal MAC state <code>crc32(mac_key)</code></h3>\n<p>The MAC is:</p>\n<pre><code>tag = crc32(mac_key + data)</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>Ck = crc32(mac_key)\ntag = crc32(data, seed=Ck)</code></pre>\n<p>And because <code>crc32(data, seed) = A * seed XOR c</code>, for a given <code>data</code> we have:</p>\n<pre><code>tag = A_data * Ck XOR c_data</code></pre>\n<p>That’s a linear equation in 32 bits. If we know:</p>\n<ul>\n<li><code>data</code> (nonce || message)</li>\n<li><code>tag</code> (given by the server)</li>\n</ul>\n<p>we can solve for <code>Ck = crc32(mac_key)</code>.</p>\n<p>How do we get <code>A<em>data</code> and <code>c</em>data</code>?</p>\n<ul>\n<li><code>c_data = crc32(data, 0)</code></li>\n<li>For each bit <code>i</code> of the seed:</li>\n</ul>\n<pre><code>s0 = 1 &lt;&lt; i\n sf = crc32(data, s0)\n column_i = sf ^ c_data   # how this seed bit influences the output</code></pre>\n<p>Stacking all columns gives us the 32×32 matrix <code>A_data</code>.   Then we invert it with Gaussian elimination over GF(2) (a 32×32 bit matrix is small) to recover:</p>\n<pre><code>Ck = A_data^{-1} * (tag ^ c_data)</code></pre>\n<p>Once we have <code>Ck = crc32(mac_key)</code>, we can compute a valid MAC for <strong>any</strong> data <code>M</code>:</p>\n<pre><code>fake_tag = crc32(M, seed=Ck)</code></pre>\n<p>Exactly like the server would.</p>\n<p>So:</p>\n<ul>\n<li>We use one of the authenticated messages from the server (e.g. the third one with the checksum list).</li>\n<li>We compute <code>Ck</code>.</li>\n<li>Then we can forge a tag for our own <code>(nonce || part1 || part2 || part3 || part4)</code>.</li>\n</ul>\n<h2>4. Building 16-byte blocks with a chosen CRC32</h2>\n<p>Now about the “cognitive reminders”:</p>\n<p>The server gives us:</p>\n<pre><code>enc_key_parts_checksums = [c0, c1, c2, c3]</code></pre>\n<p>We must produce 4 blocks <code>part_i</code> such that:</p>\n<pre><code>len(part_i) == 16\ncrc32(part_i) == c_i</code></pre>\n<p>Again, CRC32 is linear, so we can treat this like solving a linear equation.</p>\n<h3>Idea</h3>\n<ol>\n<li>Choose a random 12-byte prefix:</li>\n</ol>\n<pre><code>prefix = os.urandom(12)</code></pre>\n<ol>\n<li>Let the last 4 bytes be an unknown 32-bit integer <code>x</code> (little-endian).  </li>\n<p>So the block is <code>prefix || x</code>.</p>\n</ol>\n<ol>\n<li>Define:</li>\n</ol>\n    <pre><code>F(x) = crc32(prefix + x.to_bytes(4, 'little'))</code></pre>\n<p>Because CRC32 is linear, <code>F(x)</code> is an affine function:</p>\n<pre><code>F(x) = B * x  XOR  d</code></pre>\n<ol>\n<li>Compute:</li>\n</ol>\n<ul>\n<li><code>F0 = F(0)</code> → that’s <code>d</code>.</li>\n<li>For each bit i of x:</li>\n<p>- Let <code>x = (1 << i)</code> \t- Compute <code>Fi = F(1 << i)</code> \t- The difference <code>Fi ^ F0</code> gives you how bit i affects the CRC → column i of matrix <code>B</code>.</p>\n</ul>\n<ol>\n<li>Now, to solve for a target CRC <code>target</code>:</li>\n</ol>\n    <pre><code>F(x) = target\n    → B * x XOR F0 = target\n    → B * x = target XOR F0\n    → x = B^{-1} * (target XOR F0)</code></pre>\n<ol>\n<li>Then:</li>\n</ol>\n<pre><code>suffix = x.to_bytes(4, 'little')\nblock  = prefix + suffix</code></pre>\n<p>And by construction:</p>\n<pre><code>crc32(block) == target</code></pre>\n<p>Repeat this 4 times, once for each target CRC in the list → we get 4 valid 16-byte parts.</p>\n<h2>5. Putting it all together: the exploit flow</h2>\n<p>Here’s the full logic step-by-step.</p>\n<h3>5.1. Connect and read data</h3>\n<p>We connect with:</p>\n<pre><code>nc 10.80.8.34 1337</code></pre>\n<p>We read:</p>\n<ul>\n<li>The initial encrypted flag + its tag and nonce</li>\n<li>The “forgotten key” message + tag/nonce</li>\n<li>The checksum list <code>[c0, c1, c2, c3]</code> + tag/nonce</li>\n</ul>\n<p>We especially keep:</p>\n<ul>\n<li><code>msg3</code> = the line containing <code>[c0, c1, c2, c3]</code> as plain text</li>\n<li><code>nonce3</code>, <code>tag3</code> = from the note after that</li>\n</ul>\n<h3>5.2. Recover <code>crc32(mac_key)</code></h3>\n<p>We treat:</p>\n<pre><code>data3 = nonce3 + msg3.encode()\ntag3  = int(tag3_hex, 16)</code></pre>\n<p>We call our helper:</p>\n<pre><code>Ck = recover_crc32_key_state(data3, tag3)</code></pre>\n<p>And now <code>Ck</code> is the internal CRC state after the MAC key.   We don’t know <code>mac_key</code> itself, but we don’t care; we can MAC like the server does.</p>\n<h3>5.3. Build 4 valid key parts</h3>\n<p>For each <code>ci</code> in the given list:</p>\n<pre><code>part_i = build_block_for_crc(ci)</code></pre>\n<p>Where <code>build<em>block</em>for_crc</code> implements the “prefix + 4-byte suffix + linear solve” trick.</p>\n<p>We end up with a list:</p>\n<pre><code>parts = [part0, part1, part2, part3]  # each 16 bytes</code></pre>\n<p>And we can verify locally:</p>\n<pre><code>for p, c in zip(parts, checksums):\n    assert crc32(p) == c</code></pre>\n<h3>5.4. Choose our nonce and forge a MAC</h3>\n<p>We choose a random 4-byte nonce that we haven’t seen before:</p>\n<pre><code>new_nonce = os.urandom(4)</code></pre>\n<p>Build our message:</p>\n<pre><code>message = new_nonce + b\"\".join(parts)</code></pre>\n<p>Compute the forged tag:</p>\n<pre><code>fake_tag = crc32(message, seed=Ck)</code></pre>\n<p>We keep it as 4 bytes (big-endian or little-endian depending on the server; in our case, big-endian hex).</p>\n<h3>5.5. Talk to the server</h3>\n<p>The server asks:</p>\n<pre><code>Please remind me of my key:\nPart 1 (hex):</code></pre>\n<p>We send:</p>\n<pre><code>a96cab226baf6aec2aab327c9d96b8ce\n877434fb953113c148214dd625b83ab7\n5c469566e4e8b6faf05a68aca7c006ca\nf5786f66a44238d235621b94fd42df12</code></pre>\n<p>(Those were our specific valid parts for that instance.)</p>\n<p>Then:</p>\n<pre><code>This is an authenticated channel!\nPlease provide your nonce (hex):</code></pre>\n<p>We send:</p>\n<pre><code>47483567</code></pre>\n<p>Then:</p>\n<pre><code>Please provide the tag of the concatenation of the nonce and the 4 parts (hex):</code></pre>\n<p>We send:</p>\n<pre><code>c569a991</code></pre>\n<p>This tag is exactly:</p>\n<pre><code>crc32(new_nonce + part1 + part2 + part3 + part4, seed=Ck)</code></pre>\n<p>So the server accepts it.</p>\n<h3>5.6. Get the reward and decrypt</h3>\n<p>The server answers:</p>\n<pre><code>Thanks for reminding me! Here is a reward: &lt;reward_cipher_hex&gt;</code></pre>\n<p>We copy <code><reward<em>cipher</em>hex></code> and decrypt locally.</p>\n<p>To decrypt:</p>\n<ol>\n<li>Convert hex to bytes.</li>\n<li>Split:</li>\n</ol>\n    <pre><code>iv = data[:16]\n    ct = data[16:]</code></pre>\n<ol>\n<li>Re-derive the AES key exactly as the server does:</li>\n</ol>\n    <pre><code>hasher = Hash(SHA256())\n    for p in parts:\n        hasher.update(p)\n    key = hasher.finalize()</code></pre>\n<ol>\n<li>Decrypt AES-CBC and unpad:</li>\n</ol>\n    <pre><code>cipher = Cipher(algorithms.AES(key), modes.CBC(iv))\n    decryptor = cipher.decryptor()\n    padded = decryptor.update(ct) + decryptor.finalize()\n    \n    unpadder = PKCS7(128).unpadder()\n    plaintext = unpadder.update(padded) + unpadder.finalize()</code></pre>\n<p>The result is the flag:</p>\n<pre><code>PP{h4sh3s_4r3_m0r3_th4n_ch3cksums::9--CHRRGexlY}</code></pre>\n<h2>Why this is insecure ?</h2>\n<p>CRC32 is not a cryptographic function. It’s <em>linear</em> and has a very simple algebraic structure.</p>\n<ul>\n<li>Using <code>crc32(key || message)</code> as a MAC is <strong>completely broken</strong>:</li>\n<p>- You can model it as a matrix multiplication.     - With one authenticated message you can recover the internal state after the key.     - Then you can forge valid tags for any message, without knowing the key.</p>\n</ul>\n<p>On top of that:</p>\n<ul>\n<li>CRC32 is easy to invert on small messages; we can craft data that has any CRC32 we want.</li>\n<li>That’s how we built 16-byte blocks matching the “cognitive reminder” checksums.</li>\n</ul>\n<p>So the whole challenge is basically: “Look what happens when you treat a checksum like a cryptographic hash/MAC.”</p>\n<p>Bye Roockbye</p>",
    "tags": [
      "crypto",
      "platypwn2025",
      "CRC32",
      "MAC"
    ],
    "hash": "sha512:fb911c5e9347",
    "mitigations": [
      "Review and validate security controls",
      "Implement proper input validation",
      "Enable security monitoring and logging"
    ],
    "date": "2025-12-03T11:11:00Z"
  },
  {
    "id": "cmprw",
    "title": "C.M.P.R.W",
    "category": "crypto",
    "difficulty": "hard",
    "summary": "GlacierCTF2025 – Breaking a pseudo-random rock-paper-scissors game by recovering a 64-bit LFSR state from partial observations via constraint-based DFS.",
    "content": "<p>Some say that 75% of rock paper scissor matches end up in a tie. We suggest a more interesting one.</p>\n<p>This challenge looks like a fun little game at first: you pick one of five categories, the computer picks one too, and you win/lose based on a fixed set of rules.</p>\n<p>But the real goal is:</p>\n<p><strong>Beat the computer 200 times in a row.</strong></p>\n<p>And for the first 100 rounds, the game tells you how your choice compares to the computer's (win, lose, or tie). No punishment. Just \"free practice\".</p>\n<p>It's bait.<br>These 100 practice rounds are our way in.</p>\n\n<h2>1 – Understanding the game rules</h2>\n<p>You can choose one of these:</p>\n<pre><code>Welcome to C.M.P.R.W. If you win against the computer 200 time in a row.\nYou may claim our [SPECIAL] reward.\nHere, have some free trials as new-comer goodies.\nChoose one of 'crypto', 'misc', 'pwn', 'rev', 'web':</code></pre>\n<p>The computer also chooses one. Some choices beat others, similar to rock-paper-scissors.</p>\n<p>Imagine a circle: each category beats two others and loses to two others.</p>\n<p>So if we know what <em>the computer is going to choose</em>, we can always pick the winning option.</p>\n<p>This entire challenge becomes: <strong>Predict what the computer will choose next.</strong></p>\n\n<h2>2 – The computer is not actually random</h2>\n<p>Inside the challenge code, we find how the computer decides its choice.</p>\n<p>This is the key part:</p>\n<pre><code>choice = (state &amp; 0xf) % 5</code></pre>\n<p>Here's the idea:</p>\n<ul>\n<li>The computer keeps a <strong>big 64-bit number</strong> called <code>state</code>.</li>\n<li>To choose a move, it looks at the <strong>last 4 bits</strong> of this number.</li>\n<li>It turns that into one of the 5 categories.</li>\n<li>Then it updates the number using a fixed set of steps.</li>\n</ul>\n<p>This means: The computer is <strong>not</strong> using real randomness. It is using a predictable pattern.</p>\n<p>This pattern is called an <strong>LFSR</strong>, a simple type of pseudo-random number generator.</p>\n<p>The important part: If you know the state at any moment, you can know all future moves.</p>\n\n<h2>3 – The 100 practice rounds leak information</h2>\n<p>Every time we play, the server tells us:</p>\n<ul>\n<li>\"tie\" → the computer picked the same as us</li>\n<li>\"win\" → our choice beats the computer's</li>\n<li>\"lose\" → the computer's choice beats ours</li>\n</ul>\n<p>This gives us <strong>constraints</strong> on the value of:</p>\n<pre><code>(state_t &amp; 0xf) % 5</code></pre>\n<p>This doesn't reveal the nibble directly but it tells us which <strong>subset</strong> of 0–4 it must belong to.</p>\n<p>After 100 rounds, we have:</p>\n<ul>\n<li>100 constraints</li>\n<li>on 100 successive RNG states</li>\n</ul>\n<p>This is enough to reconstruct the <strong>initial 64-bit state</strong>.</p>\n\n<h2>4 – Recovering the Hidden RNG State</h2>\n<p>At this point, we know two things:</p>\n<ol>\n<li>The computer's choice each round is determined by <strong>the lowest nibble</strong> (4 bits) of a hidden 64-bit number (<code>state</code>).</li>\n<li>We collected <strong>100 rounds</strong> of feedback (\"win / lose / tie\"). These don't tell us the exact nibble, but they do tell us <strong>which nibble <em>mod 5</em></strong> the computer must have had.</li>\n</ol>\n<p>This means each round gives us a clue like:</p>\n<pre><code>(state_t &amp; 0xF) % 5 ∈ {some subset of 0..4}</code></pre>\n\n<h3>Breaking the 64-bit state into nibbles</h3>\n<p>A 64-bit number is simply:</p>\n<pre><code>N0 | N1 | N2 | ... | N15</code></pre>\n<p>where each Ni is a nibble (4 bits, value 0–15).</p>\n<p>So instead of solving for one giant number, we solve for <strong>16 tiny numbers</strong>, each between 0 and 15. This makes the search space manageable.</p>\n\n<h3>Phase 1: Direct narrowing (rounds 0–15)</h3>\n<p>During the <strong>first 16 rounds</strong>, the LFSR output nibble depends <strong>only on</strong> the nibble at the same position.</p>\n<p>Why? Because before the state gets mixed too much, each step of the LFSR shifts the state right, meaning:</p>\n<ul>\n<li>Round 0 output depends on N0</li>\n<li>Round 1 output depends on N1</li>\n<li>Round 2 output depends on N2</li>\n<li>…</li>\n<li>Round 15 output depends on N15</li>\n</ul>\n<p>Often, this shrinks each nibble's possibilities to <strong>2–4 values</strong> instead of 16.</p>\n\n<h3>Phase 2: Dependency tracking (rounds 16+)</h3>\n<p>After 16 rounds, each output nibble becomes a combination of <strong>several</strong> original nibbles. The script computes these dependencies in advance. For each round <code>t</code>, we compute which nibble positions in the original 64-bit state influence <code>(state_t &amp; 0xF)</code>.</p>\n<p>This is done via the functions <code>step_deps()</code> and <code>one_rng_step_deps()</code>.</p>\n\n<h3>Phase 3: Depth-First Search</h3>\n<p>The script performs a <strong>depth-first search</strong> over the 16 nibbles:</p>\n<ol>\n<li>Pick N0 from its allowed values</li>\n<li>Pick N1</li>\n<li>…up to N15</li>\n</ol>\n<p>After each assignment, the script checks: \"Given the nibbles I've already chosen, are any of the early rounds <em>guaranteed to be impossible</em>?\"</p>\n<p>To verify this, it builds a partial 64-bit state, simulates the LFSR forward, and checks all rounds where all dependencies are already known. If any output contradicts constraints → <strong>prune the branch</strong>.</p>\n<p>In practice, instead of checking 16⁶⁴ possibilities, you might only explore a few hundred valid partial states. This finishes in under a second.</p>\n\n<h3>Result</h3>\n<p>When the DFS reaches nibble 15 and all constraints match:</p>\n<ul>\n<li>The full 64-bit state has been successfully reconstructed</li>\n<li>This state reproduces exactly the outputs the server produced</li>\n<li>Your local RNG is now perfectly in sync with the server</li>\n</ul>\n<p>At that point, the RNG runs forward 100 rounds, then generates 200 predicted moves. Each predicted move is countered with its winning option. You win 200 rounds flawlessly.</p>\n\n<h2>5 – Running the full exploit</h2>\n<p>This script:</p>\n<ol>\n<li>Connects to the server</li>\n<li>Plays 100 \"crypto\" moves to gather observations</li>\n<li>Uses constraint solving to recover the 64-bit RNG state</li>\n<li>Predicts the next 200 moves</li>\n<li>Sends the winning move each time</li>\n<li>Prints the final flag</li>\n</ol>\n\n<pre><code>#!/usr/bin/env python3\n\nimport socket\n\nHOST = \"challs.glacierctf.com\"\nPORT = 13375\n\nTAGS = [\"crypto\", \"misc\", \"pwn\", \"rev\", \"web\"]\n\nedges = []\nfor i in range(len(TAGS)):\n    j1, j2 = (i + 1) % len(TAGS), (i + 3) % len(TAGS)\n    edges.append((TAGS[i], TAGS[j1]))\n    edges.append((TAGS[i], TAGS[j2]))\n\ndef result_idx(u_idx, c_idx):\n    u, c = TAGS[u_idx], TAGS[c_idx]\n    if u_idx == c_idx:\n        return \"tie\"\n    if (u, c) in edges:\n        return \"win\"\n    if (c, u) in edges:\n        return \"lose\"\n    raise RuntimeError(\"invalid result\")\n\nWIN_MOVE = {}\nfor c_idx in range(5):\n    winners = []\n    for u_idx in range(5):\n        if result_idx(u_idx, c_idx) == \"win\":\n            winners.append(u_idx)\n    WIN_MOVE[c_idx] = winners[0]\n\ndef rng_from_state(state):\n    while True:\n        yield state &amp; 0xF\n        for _ in range(4):\n            bit = (state ^ (state &gt;&gt; 3) ^ (state &gt;&gt; 7)) &amp; 1\n            state = (state &gt;&gt; 1) | (bit &lt;&lt; 63)\n\ndef step_deps(deps):\n    new = [set() for _ in range(64)]\n    tap = deps[0] ^ deps[3] ^ deps[7]\n    for i in range(63):\n        new[i] = deps[i + 1].copy()\n    new[63] = tap\n    return new\n\ndef one_rng_step_deps(deps_state):\n    out = deps_state[:4]\n    for _ in range(4):\n        deps_state = step_deps(deps_state)\n    return out, deps_state\n\nMAX_T = 200\ndeps_state = [ {i} for i in range(64) ]\nout_dep_nibbles = []\nfor t in range(MAX_T):\n    out_bits, deps_state = one_rng_step_deps(deps_state)\n    nibbles = set()\n    for bitset in out_bits:\n        for b in bitset:\n            nibbles.add(b // 4)\n    out_dep_nibbles.append(nibbles)\n\ndef recover_state_from_observations(allowed_residues, max_t_use=100):\n    T = min(max_t_use, len(allowed_residues))\n    domains = []\n    for i in range(16):\n        R = allowed_residues[i]\n        vals = [v for v in range(16) if (v % 5) in R]\n        if not vals:\n            raise RuntimeError(\"No values for nibble\", i)\n        domains.append(vals)\n\n    partial = [None] * 16\n    found_state = None\n    depN = out_dep_nibbles\n\n    def check_prefix(k):\n        state = 0\n        for i in range(k):\n            state |= (partial[i] &amp; 0xF) &lt;&lt; (4 * i)\n        rng_state = state\n        assigned_set = set(range(k))\n        for t in range(T):\n            if depN[t].issubset(assigned_set):\n                out_nib = rng_state &amp; 0xF\n                if (out_nib % 5) not in allowed_residues[t]:\n                    return False\n            for _ in range(4):\n                bit = (rng_state ^ (rng_state &gt;&gt; 3) ^ (rng_state &gt;&gt; 7)) &amp; 1\n                rng_state = (rng_state &gt;&gt; 1) | (bit &lt;&lt; 63)\n        return True\n\n    def dfs(i):\n        nonlocal found_state\n        if found_state is not None:\n            return\n        if i == 16:\n            state = 0\n            for j in range(16):\n                state |= (partial[j] &amp; 0xF) &lt;&lt; (4 * j)\n            rng_state = state\n            for t in range(T):\n                nib = rng_state &amp; 0xF\n                if (nib % 5) not in allowed_residues[t]:\n                    return\n                for _ in range(4):\n                    bit = (rng_state ^ (rng_state &gt;&gt; 3) ^ (rng_state &gt;&gt; 7)) &amp; 1\n                    rng_state = (rng_state &gt;&gt; 1) | (bit &lt;&lt; 63)\n            found_state = state\n            return\n        for v in domains[i]:\n            partial[i] = v\n            if check_prefix(i + 1):\n                dfs(i + 1)\n                if found_state is not None:\n                    return\n        partial[i] = None\n\n    dfs(0)\n    if found_state is None:\n        raise RuntimeError(\"State recovery failed\")\n    return found_state\n\ndef main():\n    s = socket.create_connection((HOST, PORT))\n    # ... (connect, play 100 rounds, recover state, win 200)\n    s.close()\n\nif __name__ == \"__main__\":\n    main()</code></pre>\n\n<p>The exploit wins all 200 rounds:</p>\n<pre><code>[+] Success! Won 200/200 rounds!\n[FLAG] gctf{y0u_4r3_7H3_TrUE_rN635u5_n0W_7rY_j3N5H1n_1Mp4C7}</code></pre>\n<p>Game over.</p>\n\n<p>By Roockbye</p>",
    "tags": [
      "crypto",
      "glacierctf2025",
      "LFSR",
      "RNG"
    ],
    "hash": "sha512:a3c7e1f09b42",
    "mitigations": [
      "Use cryptographically secure PRNGs (e.g. os.urandom, secrets module)",
      "Never use LFSRs for security-critical randomness",
      "Don't leak partial information about internal state to users",
      "Avoid games where predictability equals compromise"
    ],
    "date": "2025-12-03T11:58:00Z"
  },
  {
    "id": "tarsnap",
    "title": "Tarsnap",
    "category": "crypto",
    "difficulty": "hard",
    "summary": "HeroCTF – Compression side-channel attack (CRIME/BREACH style) on an encrypted TAR backup service to recover the flag character by character.",
    "content": "<p>Why do encrypted ZIPs exist but not encrypted TARs? Anyway, I made a 100% super secure online backup service because I'm truly paranoid.</p>\n<p>This challenge pretends to offer a \"super secure online encrypted tar archive service\".</p>\n<p>You can:</p>\n<pre><code>1. Add flag to encrypted archive\n2. Add your own file\n3. Export the encrypted archive</code></pre>\n<p>The server claims your archive is <strong>encrypted</strong>, so how could we ever recover the flag?</p>\n<p>The trick is that the encryption (ChaCha20) <strong>does not hide the size</strong> of the compressed data. And the compression algorithm leaks incredible information about the flag.</p>\n<p><strong>compression + encryption + attacker-controlled input = catastrophic leakage</strong></p>\n\n<h2>1 \u2013 How the server works internally</h2>\n<p>The server likely does something equivalent to this:</p>\n<pre><code>tar_data = build_tar(files)\ncompressed = zlib.compress(tar_data)\nencrypted = chacha20_encrypt(KEY, NONCE, compressed)\nreturn encrypted</code></pre>\n<p>Important details:</p>\n<ul>\n<li>The <strong>flag</strong> and <strong>our file</strong> are both stored inside the same TAR.</li>\n<li>The TAR is then <strong>compressed</strong>.</li>\n<li>Then the compressed result is <strong>encrypted</strong>.</li>\n<li><strong>ChaCha20 does NOT change the length</strong> of the data.</li>\n<li>The challenge shows us the <strong>hex length</strong> of the encrypted bytes.</li>\n</ul>\n<p>This means: The output size == the size of the compressed TAR.</p>\n<p>So: <strong>If compression behaves differently, the encrypted output size changes.</strong> This is the root vulnerability.</p>\n\n<h2>2 \u2013 Compression 101</h2>\n<p>Compression algorithms like DEFLATE (used by zlib) work by finding <strong>repeated patterns</strong> and replacing them with shorter references.</p>\n<p>Example:</p>\n<pre><code>Input:  ABCABCABC</code></pre>\n<p>The compressor first writes <code>ABC</code>, then notices the pattern repeats, so instead of writing the actual bytes again, it outputs:</p>\n<pre><code>(distance=3, length=3)\n(distance=3, length=3)</code></pre>\n<p>This drastically reduces the output size.</p>\n<p><strong>Key principle:</strong> The more the input contains repeated sequences, the more compression shrinks it.</p>\n\n<h2>3 \u2013 Where the vulnerability comes from</h2>\n<p>The server compresses <em>both</em> the secret flag and our controlled data <strong>together</strong> in the same stream.</p>\n<pre><code>tar = [flag.txt | guess.txt]\ncompressed = zlib.compress(tar)\nencrypted = chacha20(compressed)\nreturn encrypted_size</code></pre>\n<p>This is a <strong>fundamental mistake</strong>. Because now compression sees:</p>\n<ul>\n<li>SECRET: <code>Hero{5h0uld...}</code></li>\n<li>USER INPUT: <code>Hero{5h0uld...???</code></li>\n</ul>\n<p>If our input starts with the <strong>correct prefix</strong> of the flag:</p>\n<pre><code>Hero{5h0uld_h4v3</code></pre>\n<p>then compression will say: \"Hey, I've seen this before in the flag!\" \u2192 big compression gain \u2192 final size shrinks.</p>\n<p>If our guess is <strong>wrong</strong>:</p>\n<pre><code>Hero{XXXXXXXXXXXX</code></pre>\n<p>then compression finds fewer matches \u2192 size grows.</p>\n<p>Thus: By measuring the size of the encrypted output, we can tell if our guess matches the flag.</p>\n<p>This is called a <strong>compression side-channel attack</strong>. This class of bugs is real and dangerous:</p>\n<ul>\n<li><strong>CRIME</strong></li>\n<li><strong>BREACH</strong></li>\n<li><strong>TIME</strong></li>\n<li><strong>HEIST</strong></li>\n</ul>\n<p>All based on the exact same principle.</p>\n\n<h2>4 \u2013 Turning the leak into an oracle</h2>\n<p>We want to guess the next character of the flag. We know the flag begins with <code>Hero{</code>. Let's try guessing the next character.</p>\n<p>We test input = \"Hero{a}\". We send a file whose content contains many repetitions of:</p>\n<pre><code>salt1 + \"Hero{a\"\nsalt2 + \"Hero{a\"\n...\nsaltN + \"Hero{a\"</code></pre>\n<p>We add the flag (option 1), add our file (option 2), then export (option 3). We note the encrypted length. Then test \"Hero{b}\", \"Hero{c}\", \"Hero{0}\", \"Hero{_}\"\u2026 etc.</p>\n<p>For each candidate character <code>c</code>, we calculate: <code>length(compress(flag + our_payload \"prefix+c\"))</code></p>\n<p>The candidate <strong>producing the smallest size</strong> is the correct next character. We append it to our known prefix and repeat.</p>\n\n<h2>5 \u2013 Amplifying the leakage</h2>\n<p>The difference in size between correct and incorrect guesses can be small (sometimes 1\u20133 bytes). To make the detection reliable, we amplify the effect:</p>\n\n<h3>Many repetitions (\"CHUNKS\")</h3>\n<p>Instead of writing <code>prefix + c</code>, we send:</p>\n<pre><code>salt1 || prefix+c\nsalt2 || prefix+c\n...\nsalt800 || prefix+c</code></pre>\n<p>The repetition of \"prefix+c\" strongly boosts compression if <code>c</code> is correct.</p>\n\n<h3>Random salts</h3>\n<p>We prepend every repetition with random bytes to avoid unintended compression on other parts of the TAR structure. This ensures only the <strong>prefix+c</strong> region is the repeated pattern the compressor sees.</p>\n\n<h3>Multiple measurements (SAMPLES)</h3>\n<p>Each guess is tested multiple times because the server may introduce noise. We take the <strong>minimum</strong> or <strong>median</strong> to smooth randomness.</p>\n\n<h3>Narrowing down TOP_K</h3>\n<p>We take only the 5 best candidates (smallest size) and re-test them to select the true best.</p>\n\n<h2>6 \u2013 Exploitation script</h2>\n<p>A simplified version of the final exploit:</p>\n<pre><code>payload = b\"\".join(s + (known_prefix + candidate)\n                   for s in salts)\n\nct_len = query_length(payload.hex().encode())</code></pre>\n<p>This is repeated for all characters in the charset:</p>\n<pre><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_{}-</code></pre>\n<p>Once the character that minimizes size is found, we append it and move to the next one. The prefix grows like:</p>\n<pre><code>Hero{5\nHero{5h\nHero{5h0\nHero{5h0u\n...\nHero{5h0uld_h4v3_u53d_3ncryp7_7h3n_c0mpr355_1n5734d}</code></pre>\n<p>Exactly like solving a crossword puzzle where the server reveals \"hotter/colder\" based on compression.</p>\n\n<h3>Full exploit script</h3>\n<pre><code>#!/usr/bin/env python3\nimport os, random, string\nfrom pwn import context, remote\n\nHOST = \"crypto.heroctf.fr\"\nPORT = 9002\nPREFIX = b\"Hero{\"\nCHARSET = string.ascii_letters + string.digits + \"_{}-\"\nCHUNKS = 800\nSALT_LEN = 8\nSAMPLES = 5\nTOP_K = 5\ncontext.log_level = \"error\"\n\ndef build_payload(prefix, salts):\n    return b\"\".join(s + prefix for s in salts)\n\nclass Oracle:\n    def __init__(self):\n        self.conn = remote(HOST, PORT, timeout=10)\n\n    def query_length(self, hexdata):\n        r = self.conn\n        r.sendlineafter(b\"&gt; \", b\"1\")\n        r.sendlineafter(b\"&gt; \", b\"2\")\n        r.sendlineafter(b\"Filename: \", b\"a\")\n        r.sendlineafter(b\"Content: \", hexdata)\n        r.sendlineafter(b\"&gt; \", b\"3\")\n        line = r.recvline(timeout=5)\n        while line and b\"Encrypted content:\" not in line:\n            line = r.recvline(timeout=5)\n        cipher_hex = line.split(b\":\", 1)[1].strip()\n        return len(cipher_hex) // 2\n\ndef main():\n    salts = [os.urandom(SALT_LEN) for _ in range(CHUNKS)]\n    oracle = Oracle()\n    current = PREFIX\n    charset_bytes = [c.encode() for c in CHARSET]\n\n    while True:\n        scores = []\n        for ch in charset_bytes:\n            guess = current + ch\n            payload = build_payload(guess, salts)\n            length = oracle.query_length(payload.hex().encode())\n            scores.append((length, ch, payload.hex().encode()))\n\n        scores.sort(key=lambda x: x[0])\n        best = None\n        for l, ch, hx in scores[:TOP_K]:\n            lengths = [l]\n            for _ in range(SAMPLES - 1):\n                lengths.append(oracle.query_length(hx))\n            score = min(lengths)\n            if best is None or score &lt; best[0]:\n                best = (score, ch)\n\n        current += best[1]\n        print(f\"[+] {current.decode()}\")\n        if best[1] == b\"}\":\n            break\n\nif __name__ == \"__main__\":\n    main()</code></pre>\n\n<p>The final recovered secret was:</p>\n<pre><code>Hero{5h0uld_h4v3_u53d_3ncryp7_7h3n_c0mpr355_1n5734d}</code></pre>\n\n<p>By Roockbye</p>",
    "tags": [
      "crypto",
      "heroctf",
      "compression",
      "side-channel",
      "CRIME"
    ],
    "hash": "sha512:d8f2a1c7e930",
    "mitigations": [
      "Never compress then encrypt user-controlled data alongside secrets (CRIME/BREACH)",
      "Use authenticated encryption with padding to mask exact plaintext lengths",
      "Separate secret and attacker-controlled data into different compression contexts",
      "Add random padding before encryption to obscure compressed size"
    ],
    "date": "2025-12-03T12:30:00Z"
  }
]