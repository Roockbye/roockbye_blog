[
  {
    "id": "cognitive-reminder-call",
    "title": "Cognitive Reminder Call",
    "category": "crypto",
    "difficulty": "medium",
    "summary": "Challenge Crypto",
    "content": "<p>The server seems to be forgetful :( \nCan you help it remember?</p><p>Files provided :\n<ul><li>server.py</li>\n<li>Pipfile.lock </li>\n<li>Pipfile</li>\n<li>Dockerfile</li></p><p>We’re given a network service. When we connect, we see something like:</p><p><pre><code>Here is the flag: &lt;big hex&gt;\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag1&gt; with nonce &lt;nonce1&gt;.\nI have forgotten my key :(\nBut here are 4 congnitive reminders of my key:\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag2&gt; with nonce &lt;nonce2&gt;.\n[crc0, crc1, crc2, crc3]\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag3&gt; with nonce &lt;nonce3&gt;.\nPlease remind me of my key:\nPart 1 (hex):</code></pre></p><p><h2>1. What the server actually does</h2></p><p>Internally, the server:</p><p><li>Generates 4 random 16-byte chunks:</li></p><p> <pre><code>enc<em>key</em>parts = [os.urandom(16) for _ in range(4)]</code></pre></p><p><li>Derives an AES key from them:</li></p><p> <pre><code>key = SHA256(enc<em>key</em>parts[0] + enc<em>key</em>parts[1] +\n\t            enc<em>key</em>parts[2] + enc<em>key</em>parts[3])</code></pre></p><p><li>Encrypts the flag with AES-256-CBC and sends:</li></p><p><pre><code>Here is the flag: &lt;IV || ciphertext in hex&gt;</code></pre></p><p><li>Uses a secret <code>mac_key</code> and “authenticates” several messages using:</li></p><p><pre><code>def mac(key, message):\n\treturn crc32(key + message)   # 32-bit CRC</code></pre></p><p>So each “Note: … tag is … with nonce …” is basically:</p><p><pre><code>tag = crc32(mac_key + nonce + message)</code></pre></p><p><li>Then it “forgets” the real <code>enc<em>key</em>parts</code>, but gives us these <strong>4 CRC32 values</strong>:</li></p><p>  <pre><code>enc<em>key</em>parts<em>checksums = [crc32(part) for part in enc</em>key_parts]</code></pre></p><p>and asks us:\n<li>4 parts, each 16 bytes, in hex</li>\n<li>a nonce (4 bytes in hex)</li>\n<li>a tag = <code>crc32(mac_key + nonce + part1 + part2 + part3 + part4)</code></li></p><p><li>If our tag is valid <strong>and</strong> all 4 parts have the correct CRC32, it accepts our “reminder”, recomputes the AES key from <strong>our</strong> parts, and sends:</li></p><p>    <pre><code>Thanks for reminding me! Here is a reward: &lt;IV || ciphertext’ hex&gt;</code></pre></p><p>This new ciphertext is the <em>same plaintext flag</em>, but encrypted with the key derived from <strong>our</strong> 4 parts.</p><p>If we can:\n<li>forge a valid MAC, and</li>\n<li>craft 4 parts that match the required CRC32s,</li></p><p>we can decrypt this second ciphertext and get the flag.</p><p><h2>2. Big picture of the attack</h2></p><p>We want to:</p><p><li><strong>Break the MAC</strong>: <code>crc32(mac_key || message)</code>  </li>\n→ forge a valid tag for <code>nonce || part1 || part2 || part3 || part4</code> without knowing <code>mac_key</code>.</p><p><li><strong>Forge the 4 key parts</strong>:  </li>\nFor each target CRC <code>ci</code> in the list <code>[c0, c1, c2, c3]</code> we must build a 16-byte block <code>part_i</code> such that:</p><p><pre><code>crc32(part_i) == ci</code></pre></p><p><li><strong>Get the final ciphertext</strong>, decrypt with <strong>our</strong> AES key and recover the flag.</li></p><p>Both come from the same fact: <strong>CRC32 is linear and totally not a secure MAC</strong>.</p><p><h2>3. Understanding CRC32 as a linear function</h2></p><p>In Python, <code>binascii.crc32(data, seed)</code> behaves like this:</p><p><pre><code>crc32(data, seed) = A<em>data * seed  XOR  c</em>data</code></pre></p><p>Where:\n<li><code>seed</code> and the result are 32-bit integers</li>\n<li>operations are over GF(2) (bitwise linear algebra)</li>\n<li><code>A_data</code> is a 32×32 binary matrix</li>\n<li><code>c_data</code> is a 32-bit constant</li></p><p>We don’t need to derive them by hand; we can <em>ask</em> the function by probing different seeds.</p><p><h3>3.1. Recovering the internal MAC state <code>crc32(mac_key)</code></h3></p><p>The MAC is:\n<pre><code>tag = crc32(mac_key + data)</code></pre></p><p>This is equivalent to:\n<pre><code>Ck = crc32(mac_key)\ntag = crc32(data, seed=Ck)</code></pre></p><p>And because <code>crc32(data, seed) = A * seed XOR c</code>, for a given <code>data</code> we have:\n<pre><code>tag = A<em>data * Ck XOR c</em>data</code></pre></p><p>That’s a linear equation in 32 bits. If we know:\n<li><code>data</code> (nonce || message)</li>\n<li><code>tag</code> (given by the server)</li></p><p>we can solve for <code>Ck = crc32(mac_key)</code>.</p><p>How do we get <code>A<em>data</code> and <code>c</em>data</code>?\n<li><code>c_data = crc32(data, 0)</code></li>\n<li>For each bit <code>i</code> of the seed:</li>\n<pre><code>s0 = 1 &lt;&lt; i\n sf = crc32(data, s0)\n column<em>i = sf ^ c</em>data   # how this seed bit influences the output</code></pre></p><p>Stacking all columns gives us the 32×32 matrix <code>A_data</code>.  \nThen we invert it with Gaussian elimination over GF(2) (a 32×32 bit matrix is small) to recover:\n<pre><code>Ck = A<em>data^{-1} * (tag ^ c</em>data)</code></pre></p><p>Once we have <code>Ck = crc32(mac_key)</code>, we can compute a valid MAC for <strong>any</strong> data <code>M</code>:\n<pre><code>fake_tag = crc32(M, seed=Ck)</code></pre></p><p>Exactly like the server would.</p><p>So:\n<li>We use one of the authenticated messages from the server (e.g. the third one with the checksum list).</li>\n<li>We compute <code>Ck</code>.</li>\n<li>Then we can forge a tag for our own <code>(nonce || part1 || part2 || part3 || part4)</code>.</li></p><p><h2>4. Building 16-byte blocks with a chosen CRC32</h2></p><p>Now about the “cognitive reminders”:</p><p>The server gives us:\n<pre><code>enc<em>key</em>parts_checksums = [c0, c1, c2, c3]</code></pre></p><p>We must produce 4 blocks <code>part_i</code> such that:\n<pre><code>len(part_i) == 16\ncrc32(part<em>i) == c</em>i</code></pre></p><p>Again, CRC32 is linear, so we can treat this like solving a linear equation.\n<h3>Idea</h3></p><p><li>Choose a random 12-byte prefix:</li></p><p><pre><code>prefix = os.urandom(12)</code></pre></p><p><li>Let the last 4 bytes be an unknown 32-bit integer <code>x</code> (little-endian).  </li>\nSo the block is <code>prefix || x</code>.</p><p><li>Define:</li>\n    <pre><code>F(x) = crc32(prefix + x.to_bytes(4, 'little'))</code></pre></p><p>Because CRC32 is linear, <code>F(x)</code> is an affine function:\n<pre><code>F(x) = B * x  XOR  d</code></pre></p><p><li>Compute:</li>\n<li><code>F0 = F(0)</code> → that’s <code>d</code>.</li>\n<li>For each bit i of x:</li>\n\t- Let <code>x = (1 << i)</code>\n\t- Compute <code>Fi = F(1 << i)</code>\n\t- The difference <code>Fi ^ F0</code> gives you how bit i affects the CRC → column i of matrix <code>B</code>.</p><p><li>Now, to solve for a target CRC <code>target</code>:</li>\n    <pre><code>F(x) = target\n    → B * x XOR F0 = target\n    → B * x = target XOR F0\n    → x = B^{-1} * (target XOR F0)</code></pre>\n<li>Then:</li>\n<pre><code>suffix = x.to_bytes(4, 'little')\nblock  = prefix + suffix</code></pre>\nAnd by construction:\n<pre><code>crc32(block) == target</code></pre></p><p>Repeat this 4 times, once for each target CRC in the list → we get 4 valid 16-byte parts.</p><p><h2>5. Putting it all together: the exploit flow</h2></p><p>Here’s the full logic step-by-step.\n<h3>5.1. Connect and read data</h3></p><p>We connect with:\n<pre><code>nc 10.80.8.34 1337</code></pre></p><p>We read:\n<li>The initial encrypted flag + its tag and nonce</li>\n<li>The “forgotten key” message + tag/nonce</li>\n<li>The checksum list <code>[c0, c1, c2, c3]</code> + tag/nonce</li></p><p>We especially keep:\n<li><code>msg3</code> = the line containing <code>[c0, c1, c2, c3]</code> as plain text</li>\n<li><code>nonce3</code>, <code>tag3</code> = from the note after that</li>\n<h3>5.2. Recover <code>crc32(mac_key)</code></h3></p><p>We treat:\n<pre><code>data3 = nonce3 + msg3.encode()\ntag3  = int(tag3_hex, 16)</code></pre></p><p>We call our helper:\n<pre><code>Ck = recover<em>crc32</em>key_state(data3, tag3)</code></pre></p><p>And now <code>Ck</code> is the internal CRC state after the MAC key.  \nWe don’t know <code>mac_key</code> itself, but we don’t care; we can MAC like the server does.</p><p><h3>5.3. Build 4 valid key parts</h3></p><p>For each <code>ci</code> in the given list:\n<pre><code>part<em>i = build</em>block<em>for</em>crc(ci)</code></pre></p><p>Where <code>build<em>block</em>for_crc</code> implements the “prefix + 4-byte suffix + linear solve” trick.</p><p>We end up with a list:\n<pre><code>parts = [part0, part1, part2, part3]  # each 16 bytes</code></pre></p><p>And we can verify locally:\n<pre><code>for p, c in zip(parts, checksums):\n    assert crc32(p) == c</code></pre></p><p><h3>5.4. Choose our nonce and forge a MAC</h3></p><p>We choose a random 4-byte nonce that we haven’t seen before:\n<pre><code>new_nonce = os.urandom(4)</code></pre></p><p>Build our message:\n<pre><code>message = new_nonce + b\"\".join(parts)</code></pre></p><p>Compute the forged tag:\n<pre><code>fake_tag = crc32(message, seed=Ck)</code></pre></p><p>We keep it as 4 bytes (big-endian or little-endian depending on the server; in our case, big-endian hex).</p><p><h3>5.5. Talk to the server</h3></p><p>The server asks:\n<pre><code>Please remind me of my key:\nPart 1 (hex):</code></pre></p><p>We send:\n<pre><code>a96cab226baf6aec2aab327c9d96b8ce\n877434fb953113c148214dd625b83ab7\n5c469566e4e8b6faf05a68aca7c006ca\nf5786f66a44238d235621b94fd42df12</code></pre></p><p>(Those were our specific valid parts for that instance.)</p><p>Then:\n<pre><code>This is an authenticated channel!\nPlease provide your nonce (hex):</code></pre></p><p>We send:\n<pre><code>47483567</code></pre></p><p>Then:\n<pre><code>Please provide the tag of the concatenation of the nonce and the 4 parts (hex):</code></pre></p><p>We send:\n<pre><code>c569a991</code></pre></p><p>This tag is exactly:\n<pre><code>crc32(new_nonce + part1 + part2 + part3 + part4, seed=Ck)</code></pre></p><p>So the server accepts it.</p><p><h3>5.6. Get the reward and decrypt</h3></p><p>The server answers:\n<pre><code>Thanks for reminding me! Here is a reward: &lt;reward<em>cipher</em>hex&gt;</code></pre></p><p>We copy <code><reward<em>cipher</em>hex></code> and decrypt locally.</p><p>To decrypt:\n<li>Convert hex to bytes.</li>\n<li>Split:</li>\n    <pre><code>iv = data[:16]\n    ct = data[16:]</code></pre>\n<li>Re-derive the AES key exactly as the server does:</li>\n    <pre><code>hasher = Hash(SHA256())\n    for p in parts:\n        hasher.update(p)\n    key = hasher.finalize()</code></pre>\n<li>Decrypt AES-CBC and unpad:</li>\n    <pre><code>cipher = Cipher(algorithms.AES(key), modes.CBC(iv))\n    decryptor = cipher.decryptor()\n    padded = decryptor.update(ct) + decryptor.finalize()\n    \n    unpadder = PKCS7(128).unpadder()\n    plaintext = unpadder.update(padded) + unpadder.finalize()</code></pre></p><p>The result is the flag:\n<pre><code>PP{h4sh3s<em>4r3</em>m0r3<em>th4n</em>ch3cksums::9--CHRRGexlY}</code></pre></p><p><h2>Why this is insecure ?</h2></p><p> CRC32 is not a cryptographic function. It’s <em>linear</em> and has a very simple algebraic structure.</p><p><li>Using <code>crc32(key || message)</code> as a MAC is <strong>completely broken</strong>:</li>\n    - You can model it as a matrix multiplication.\n    - With one authenticated message you can recover the internal state after the key.\n    - Then you can forge valid tags for any message, without knowing the key.</p><p>On top of that:\n<li>CRC32 is easy to invert on small messages; we can craft data that has any CRC32 we want.</li>\n<li>That’s how we built 16-byte blocks matching the “cognitive reminder” checksums.</li></ul></p><p>So the whole challenge is basically:\n“Look what happens when you treat a checksum like a cryptographic hash/MAC.”</p><p>Bye Roockbye</p>",
    "tags": [
      "crypto",
      "platypwn2025",
      "CRC32",
      "MAC"
    ],
    "hash": "sha512:fb911c5e9347",
    "mitigations": [
      "Review and validate security controls",
      "Implement proper input validation",
      "Enable security monitoring and logging"
    ],
    "date": "2025-12-03T11:11:00Z"
  }
]