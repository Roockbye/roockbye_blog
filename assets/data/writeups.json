[
  {
    "id": "cognitive-reminder-call",
    "title": "Cognitive Reminder Call",
    "category": "crypto",
    "difficulty": "medium",
    "summary": "Challenge Crypto",
    "content": "<p>The server seems to be forgetful :(  Can you help it remember?</p>\n<p>Files provided :</p>\n<ul>\n<li>server.py</li>\n<li>Pipfile.lock </li>\n<li>Pipfile</li>\n<li>Dockerfile</li>\n</ul>\n<p>We’re given a network service. When we connect, we see something like:</p>\n<pre><code>Here is the flag: &lt;big hex&gt;\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag1&gt; with nonce &lt;nonce1&gt;.\nI have forgotten my key :(\nBut here are 4 congnitive reminders of my key:\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag2&gt; with nonce &lt;nonce2&gt;.\n[crc0, crc1, crc2, crc3]\nNote: This message was sent over an authenticated channel. Its tag is &lt;tag3&gt; with nonce &lt;nonce3&gt;.\nPlease remind me of my key:\nPart 1 (hex):</code></pre>\n<h2>1. What the server actually does</h2>\n<p>Internally, the server:</p>\n<ol>\n<li>Generates 4 random 16-byte chunks:</li>\n</ol>\n <pre><code>enc_key_parts = [os.urandom(16) for _ in range(4)]</code></pre>\n<ol>\n<li>Derives an AES key from them:</li>\n</ol>\n <pre><code>key = SHA256(enc_key_parts[0] + enc_key_parts[1] +\n\t            enc_key_parts[2] + enc_key_parts[3])</code></pre>\n<ol>\n<li>Encrypts the flag with AES-256-CBC and sends:</li>\n</ol>\n<pre><code>Here is the flag: &lt;IV || ciphertext in hex&gt;</code></pre>\n<ol>\n<li>Uses a secret <code>mac_key</code> and “authenticates” several messages using:</li>\n</ol>\n<pre><code>def mac(key, message):\n\treturn crc32(key + message)   # 32-bit CRC</code></pre>\n<p>So each “Note: … tag is … with nonce …” is basically:</p>\n<pre><code>tag = crc32(mac_key + nonce + message)</code></pre>\n<ol>\n<li>Then it “forgets” the real <code>enc<em>key</em>parts</code>, but gives us these <strong>4 CRC32 values</strong>:</li>\n</ol>\n  <pre><code>enc_key_parts_checksums = [crc32(part) for part in enc_key_parts]</code></pre>\n<p>and asks us:</p>\n<ul>\n<li>4 parts, each 16 bytes, in hex</li>\n<li>a nonce (4 bytes in hex)</li>\n<li>a tag = <code>crc32(mac_key + nonce + part1 + part2 + part3 + part4)</code></li>\n</ul>\n<ol>\n<li>If our tag is valid <strong>and</strong> all 4 parts have the correct CRC32, it accepts our “reminder”, recomputes the AES key from <strong>our</strong> parts, and sends:</li>\n</ol>\n    <pre><code>Thanks for reminding me! Here is a reward: &lt;IV || ciphertext’ hex&gt;</code></pre>\n<p>This new ciphertext is the <em>same plaintext flag</em>, but encrypted with the key derived from <strong>our</strong> 4 parts.</p>\n<p>If we can:</p>\n<ul>\n<li>forge a valid MAC, and</li>\n<li>craft 4 parts that match the required CRC32s,</li>\n</ul>\n<p>we can decrypt this second ciphertext and get the flag.</p>\n<h2>2. Big picture of the attack</h2>\n<p>We want to:</p>\n<ol>\n<li><strong>Break the MAC</strong>: <code>crc32(mac_key || message)</code>  </li>\n<p>→ forge a valid tag for <code>nonce || part1 || part2 || part3 || part4</code> without knowing <code>mac_key</code>.</p>\n</ol>\n<ol>\n<li><strong>Forge the 4 key parts</strong>:  </li>\n<p>For each target CRC <code>ci</code> in the list <code>[c0, c1, c2, c3]</code> we must build a 16-byte block <code>part_i</code> such that:</p>\n</ol>\n<pre><code>crc32(part_i) == ci</code></pre>\n<ol>\n<li><strong>Get the final ciphertext</strong>, decrypt with <strong>our</strong> AES key and recover the flag.</li>\n</ol>\n<p>Both come from the same fact: <strong>CRC32 is linear and totally not a secure MAC</strong>.</p>\n<h2>3. Understanding CRC32 as a linear function</h2>\n<p>In Python, <code>binascii.crc32(data, seed)</code> behaves like this:</p>\n<pre><code>crc32(data, seed) = A_data * seed  XOR  c_data</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>seed</code> and the result are 32-bit integers</li>\n<li>operations are over GF(2) (bitwise linear algebra)</li>\n<li><code>A_data</code> is a 32×32 binary matrix</li>\n<li><code>c_data</code> is a 32-bit constant</li>\n</ul>\n<p>We don’t need to derive them by hand; we can <em>ask</em> the function by probing different seeds.</p>\n<h3>3.1. Recovering the internal MAC state <code>crc32(mac_key)</code></h3>\n<p>The MAC is:</p>\n<pre><code>tag = crc32(mac_key + data)</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>Ck = crc32(mac_key)\ntag = crc32(data, seed=Ck)</code></pre>\n<p>And because <code>crc32(data, seed) = A * seed XOR c</code>, for a given <code>data</code> we have:</p>\n<pre><code>tag = A_data * Ck XOR c_data</code></pre>\n<p>That’s a linear equation in 32 bits. If we know:</p>\n<ul>\n<li><code>data</code> (nonce || message)</li>\n<li><code>tag</code> (given by the server)</li>\n</ul>\n<p>we can solve for <code>Ck = crc32(mac_key)</code>.</p>\n<p>How do we get <code>A<em>data</code> and <code>c</em>data</code>?</p>\n<ul>\n<li><code>c_data = crc32(data, 0)</code></li>\n<li>For each bit <code>i</code> of the seed:</li>\n</ul>\n<pre><code>s0 = 1 &lt;&lt; i\n sf = crc32(data, s0)\n column_i = sf ^ c_data   # how this seed bit influences the output</code></pre>\n<p>Stacking all columns gives us the 32×32 matrix <code>A_data</code>.   Then we invert it with Gaussian elimination over GF(2) (a 32×32 bit matrix is small) to recover:</p>\n<pre><code>Ck = A_data^{-1} * (tag ^ c_data)</code></pre>\n<p>Once we have <code>Ck = crc32(mac_key)</code>, we can compute a valid MAC for <strong>any</strong> data <code>M</code>:</p>\n<pre><code>fake_tag = crc32(M, seed=Ck)</code></pre>\n<p>Exactly like the server would.</p>\n<p>So:</p>\n<ul>\n<li>We use one of the authenticated messages from the server (e.g. the third one with the checksum list).</li>\n<li>We compute <code>Ck</code>.</li>\n<li>Then we can forge a tag for our own <code>(nonce || part1 || part2 || part3 || part4)</code>.</li>\n</ul>\n<h2>4. Building 16-byte blocks with a chosen CRC32</h2>\n<p>Now about the “cognitive reminders”:</p>\n<p>The server gives us:</p>\n<pre><code>enc_key_parts_checksums = [c0, c1, c2, c3]</code></pre>\n<p>We must produce 4 blocks <code>part_i</code> such that:</p>\n<pre><code>len(part_i) == 16\ncrc32(part_i) == c_i</code></pre>\n<p>Again, CRC32 is linear, so we can treat this like solving a linear equation.</p>\n<h3>Idea</h3>\n<ol>\n<li>Choose a random 12-byte prefix:</li>\n</ol>\n<pre><code>prefix = os.urandom(12)</code></pre>\n<ol>\n<li>Let the last 4 bytes be an unknown 32-bit integer <code>x</code> (little-endian).  </li>\n<p>So the block is <code>prefix || x</code>.</p>\n</ol>\n<ol>\n<li>Define:</li>\n</ol>\n    <pre><code>F(x) = crc32(prefix + x.to_bytes(4, 'little'))</code></pre>\n<p>Because CRC32 is linear, <code>F(x)</code> is an affine function:</p>\n<pre><code>F(x) = B * x  XOR  d</code></pre>\n<ol>\n<li>Compute:</li>\n</ol>\n<ul>\n<li><code>F0 = F(0)</code> → that’s <code>d</code>.</li>\n<li>For each bit i of x:</li>\n<p>- Let <code>x = (1 << i)</code> \t- Compute <code>Fi = F(1 << i)</code> \t- The difference <code>Fi ^ F0</code> gives you how bit i affects the CRC → column i of matrix <code>B</code>.</p>\n</ul>\n<ol>\n<li>Now, to solve for a target CRC <code>target</code>:</li>\n</ol>\n    <pre><code>F(x) = target\n    → B * x XOR F0 = target\n    → B * x = target XOR F0\n    → x = B^{-1} * (target XOR F0)</code></pre>\n<ol>\n<li>Then:</li>\n</ol>\n<pre><code>suffix = x.to_bytes(4, 'little')\nblock  = prefix + suffix</code></pre>\n<p>And by construction:</p>\n<pre><code>crc32(block) == target</code></pre>\n<p>Repeat this 4 times, once for each target CRC in the list → we get 4 valid 16-byte parts.</p>\n<h2>5. Putting it all together: the exploit flow</h2>\n<p>Here’s the full logic step-by-step.</p>\n<h3>5.1. Connect and read data</h3>\n<p>We connect with:</p>\n<pre><code>nc 10.80.8.34 1337</code></pre>\n<p>We read:</p>\n<ul>\n<li>The initial encrypted flag + its tag and nonce</li>\n<li>The “forgotten key” message + tag/nonce</li>\n<li>The checksum list <code>[c0, c1, c2, c3]</code> + tag/nonce</li>\n</ul>\n<p>We especially keep:</p>\n<ul>\n<li><code>msg3</code> = the line containing <code>[c0, c1, c2, c3]</code> as plain text</li>\n<li><code>nonce3</code>, <code>tag3</code> = from the note after that</li>\n</ul>\n<h3>5.2. Recover <code>crc32(mac_key)</code></h3>\n<p>We treat:</p>\n<pre><code>data3 = nonce3 + msg3.encode()\ntag3  = int(tag3_hex, 16)</code></pre>\n<p>We call our helper:</p>\n<pre><code>Ck = recover_crc32_key_state(data3, tag3)</code></pre>\n<p>And now <code>Ck</code> is the internal CRC state after the MAC key.   We don’t know <code>mac_key</code> itself, but we don’t care; we can MAC like the server does.</p>\n<h3>5.3. Build 4 valid key parts</h3>\n<p>For each <code>ci</code> in the given list:</p>\n<pre><code>part_i = build_block_for_crc(ci)</code></pre>\n<p>Where <code>build<em>block</em>for_crc</code> implements the “prefix + 4-byte suffix + linear solve” trick.</p>\n<p>We end up with a list:</p>\n<pre><code>parts = [part0, part1, part2, part3]  # each 16 bytes</code></pre>\n<p>And we can verify locally:</p>\n<pre><code>for p, c in zip(parts, checksums):\n    assert crc32(p) == c</code></pre>\n<h3>5.4. Choose our nonce and forge a MAC</h3>\n<p>We choose a random 4-byte nonce that we haven’t seen before:</p>\n<pre><code>new_nonce = os.urandom(4)</code></pre>\n<p>Build our message:</p>\n<pre><code>message = new_nonce + b\"\".join(parts)</code></pre>\n<p>Compute the forged tag:</p>\n<pre><code>fake_tag = crc32(message, seed=Ck)</code></pre>\n<p>We keep it as 4 bytes (big-endian or little-endian depending on the server; in our case, big-endian hex).</p>\n<h3>5.5. Talk to the server</h3>\n<p>The server asks:</p>\n<pre><code>Please remind me of my key:\nPart 1 (hex):</code></pre>\n<p>We send:</p>\n<pre><code>a96cab226baf6aec2aab327c9d96b8ce\n877434fb953113c148214dd625b83ab7\n5c469566e4e8b6faf05a68aca7c006ca\nf5786f66a44238d235621b94fd42df12</code></pre>\n<p>(Those were our specific valid parts for that instance.)</p>\n<p>Then:</p>\n<pre><code>This is an authenticated channel!\nPlease provide your nonce (hex):</code></pre>\n<p>We send:</p>\n<pre><code>47483567</code></pre>\n<p>Then:</p>\n<pre><code>Please provide the tag of the concatenation of the nonce and the 4 parts (hex):</code></pre>\n<p>We send:</p>\n<pre><code>c569a991</code></pre>\n<p>This tag is exactly:</p>\n<pre><code>crc32(new_nonce + part1 + part2 + part3 + part4, seed=Ck)</code></pre>\n<p>So the server accepts it.</p>\n<h3>5.6. Get the reward and decrypt</h3>\n<p>The server answers:</p>\n<pre><code>Thanks for reminding me! Here is a reward: &lt;reward_cipher_hex&gt;</code></pre>\n<p>We copy <code><reward<em>cipher</em>hex></code> and decrypt locally.</p>\n<p>To decrypt:</p>\n<ol>\n<li>Convert hex to bytes.</li>\n<li>Split:</li>\n</ol>\n    <pre><code>iv = data[:16]\n    ct = data[16:]</code></pre>\n<ol>\n<li>Re-derive the AES key exactly as the server does:</li>\n</ol>\n    <pre><code>hasher = Hash(SHA256())\n    for p in parts:\n        hasher.update(p)\n    key = hasher.finalize()</code></pre>\n<ol>\n<li>Decrypt AES-CBC and unpad:</li>\n</ol>\n    <pre><code>cipher = Cipher(algorithms.AES(key), modes.CBC(iv))\n    decryptor = cipher.decryptor()\n    padded = decryptor.update(ct) + decryptor.finalize()\n    \n    unpadder = PKCS7(128).unpadder()\n    plaintext = unpadder.update(padded) + unpadder.finalize()</code></pre>\n<p>The result is the flag:</p>\n<pre><code>PP{h4sh3s_4r3_m0r3_th4n_ch3cksums::9--CHRRGexlY}</code></pre>\n<h2>Why this is insecure ?</h2>\n<p>CRC32 is not a cryptographic function. It’s <em>linear</em> and has a very simple algebraic structure.</p>\n<ul>\n<li>Using <code>crc32(key || message)</code> as a MAC is <strong>completely broken</strong>:</li>\n<p>- You can model it as a matrix multiplication.     - With one authenticated message you can recover the internal state after the key.     - Then you can forge valid tags for any message, without knowing the key.</p>\n</ul>\n<p>On top of that:</p>\n<ul>\n<li>CRC32 is easy to invert on small messages; we can craft data that has any CRC32 we want.</li>\n<li>That’s how we built 16-byte blocks matching the “cognitive reminder” checksums.</li>\n</ul>\n<p>So the whole challenge is basically: “Look what happens when you treat a checksum like a cryptographic hash/MAC.”</p>\n<p>Bye Roockbye</p>",
    "tags": [
      "crypto",
      "platypwn2025",
      "CRC32",
      "MAC"
    ],
    "hash": "sha512:fb911c5e9347",
    "mitigations": [
      "Review and validate security controls",
      "Implement proper input validation",
      "Enable security monitoring and logging"
    ],
    "date": "2025-12-03T11:11:00Z"
  },
  {
    "id": "cmprw",
    "title": "C.M.P.R.W",
    "category": "crypto",
    "difficulty": "hard",
    "summary": "GlacierCTF2025 – Breaking a pseudo-random rock-paper-scissors game by recovering a 64-bit LFSR state from partial observations via constraint-based DFS.",
    "content": "<p>Some say that 75% of rock paper scissor matches end up in a tie. We suggest a more interesting one.</p>\n<p>This challenge looks like a fun little game at first: you pick one of five categories, the computer picks one too, and you win/lose based on a fixed set of rules.</p>\n<p>But the real goal is:</p>\n<p><strong>Beat the computer 200 times in a row.</strong></p>\n<p>And for the first 100 rounds, the game tells you how your choice compares to the computer's (win, lose, or tie). No punishment. Just \"free practice\".</p>\n<p>It's bait.<br>These 100 practice rounds are our way in.</p>\n\n<h2>1 – Understanding the game rules</h2>\n<p>You can choose one of these:</p>\n<pre><code>Welcome to C.M.P.R.W. If you win against the computer 200 time in a row.\nYou may claim our [SPECIAL] reward.\nHere, have some free trials as new-comer goodies.\nChoose one of 'crypto', 'misc', 'pwn', 'rev', 'web':</code></pre>\n<p>The computer also chooses one. Some choices beat others, similar to rock-paper-scissors.</p>\n<p>Imagine a circle: each category beats two others and loses to two others.</p>\n<p>So if we know what <em>the computer is going to choose</em>, we can always pick the winning option.</p>\n<p>This entire challenge becomes: <strong>Predict what the computer will choose next.</strong></p>\n\n<h2>2 – The computer is not actually random</h2>\n<p>Inside the challenge code, we find how the computer decides its choice.</p>\n<p>This is the key part:</p>\n<pre><code>choice = (state &amp; 0xf) % 5</code></pre>\n<p>Here's the idea:</p>\n<ul>\n<li>The computer keeps a <strong>big 64-bit number</strong> called <code>state</code>.</li>\n<li>To choose a move, it looks at the <strong>last 4 bits</strong> of this number.</li>\n<li>It turns that into one of the 5 categories.</li>\n<li>Then it updates the number using a fixed set of steps.</li>\n</ul>\n<p>This means: The computer is <strong>not</strong> using real randomness. It is using a predictable pattern.</p>\n<p>This pattern is called an <strong>LFSR</strong>, a simple type of pseudo-random number generator.</p>\n<p>The important part: If you know the state at any moment, you can know all future moves.</p>\n\n<h2>3 – The 100 practice rounds leak information</h2>\n<p>Every time we play, the server tells us:</p>\n<ul>\n<li>\"tie\" → the computer picked the same as us</li>\n<li>\"win\" → our choice beats the computer's</li>\n<li>\"lose\" → the computer's choice beats ours</li>\n</ul>\n<p>This gives us <strong>constraints</strong> on the value of:</p>\n<pre><code>(state_t &amp; 0xf) % 5</code></pre>\n<p>This doesn't reveal the nibble directly but it tells us which <strong>subset</strong> of 0–4 it must belong to.</p>\n<p>After 100 rounds, we have:</p>\n<ul>\n<li>100 constraints</li>\n<li>on 100 successive RNG states</li>\n</ul>\n<p>This is enough to reconstruct the <strong>initial 64-bit state</strong>.</p>\n\n<h2>4 – Recovering the Hidden RNG State</h2>\n<p>At this point, we know two things:</p>\n<ol>\n<li>The computer's choice each round is determined by <strong>the lowest nibble</strong> (4 bits) of a hidden 64-bit number (<code>state</code>).</li>\n<li>We collected <strong>100 rounds</strong> of feedback (\"win / lose / tie\"). These don't tell us the exact nibble, but they do tell us <strong>which nibble <em>mod 5</em></strong> the computer must have had.</li>\n</ol>\n<p>This means each round gives us a clue like:</p>\n<pre><code>(state_t &amp; 0xF) % 5 ∈ {some subset of 0..4}</code></pre>\n\n<h3>Breaking the 64-bit state into nibbles</h3>\n<p>A 64-bit number is simply:</p>\n<pre><code>N0 | N1 | N2 | ... | N15</code></pre>\n<p>where each Ni is a nibble (4 bits, value 0–15).</p>\n<p>So instead of solving for one giant number, we solve for <strong>16 tiny numbers</strong>, each between 0 and 15. This makes the search space manageable.</p>\n\n<h3>Phase 1: Direct narrowing (rounds 0–15)</h3>\n<p>During the <strong>first 16 rounds</strong>, the LFSR output nibble depends <strong>only on</strong> the nibble at the same position.</p>\n<p>Why? Because before the state gets mixed too much, each step of the LFSR shifts the state right, meaning:</p>\n<ul>\n<li>Round 0 output depends on N0</li>\n<li>Round 1 output depends on N1</li>\n<li>Round 2 output depends on N2</li>\n<li>…</li>\n<li>Round 15 output depends on N15</li>\n</ul>\n<p>Often, this shrinks each nibble's possibilities to <strong>2–4 values</strong> instead of 16.</p>\n\n<h3>Phase 2: Dependency tracking (rounds 16+)</h3>\n<p>After 16 rounds, each output nibble becomes a combination of <strong>several</strong> original nibbles. The script computes these dependencies in advance. For each round <code>t</code>, we compute which nibble positions in the original 64-bit state influence <code>(state_t &amp; 0xF)</code>.</p>\n<p>This is done via the functions <code>step_deps()</code> and <code>one_rng_step_deps()</code>.</p>\n\n<h3>Phase 3: Depth-First Search</h3>\n<p>The script performs a <strong>depth-first search</strong> over the 16 nibbles:</p>\n<ol>\n<li>Pick N0 from its allowed values</li>\n<li>Pick N1</li>\n<li>…up to N15</li>\n</ol>\n<p>After each assignment, the script checks: \"Given the nibbles I've already chosen, are any of the early rounds <em>guaranteed to be impossible</em>?\"</p>\n<p>To verify this, it builds a partial 64-bit state, simulates the LFSR forward, and checks all rounds where all dependencies are already known. If any output contradicts constraints → <strong>prune the branch</strong>.</p>\n<p>In practice, instead of checking 16⁶⁴ possibilities, you might only explore a few hundred valid partial states. This finishes in under a second.</p>\n\n<h3>Result</h3>\n<p>When the DFS reaches nibble 15 and all constraints match:</p>\n<ul>\n<li>The full 64-bit state has been successfully reconstructed</li>\n<li>This state reproduces exactly the outputs the server produced</li>\n<li>Your local RNG is now perfectly in sync with the server</li>\n</ul>\n<p>At that point, the RNG runs forward 100 rounds, then generates 200 predicted moves. Each predicted move is countered with its winning option. You win 200 rounds flawlessly.</p>\n\n<h2>5 – Running the full exploit</h2>\n<p>This script:</p>\n<ol>\n<li>Connects to the server</li>\n<li>Plays 100 \"crypto\" moves to gather observations</li>\n<li>Uses constraint solving to recover the 64-bit RNG state</li>\n<li>Predicts the next 200 moves</li>\n<li>Sends the winning move each time</li>\n<li>Prints the final flag</li>\n</ol>\n\n<pre><code>#!/usr/bin/env python3\n\nimport socket\n\nHOST = \"challs.glacierctf.com\"\nPORT = 13375\n\nTAGS = [\"crypto\", \"misc\", \"pwn\", \"rev\", \"web\"]\n\nedges = []\nfor i in range(len(TAGS)):\n    j1, j2 = (i + 1) % len(TAGS), (i + 3) % len(TAGS)\n    edges.append((TAGS[i], TAGS[j1]))\n    edges.append((TAGS[i], TAGS[j2]))\n\ndef result_idx(u_idx, c_idx):\n    u, c = TAGS[u_idx], TAGS[c_idx]\n    if u_idx == c_idx:\n        return \"tie\"\n    if (u, c) in edges:\n        return \"win\"\n    if (c, u) in edges:\n        return \"lose\"\n    raise RuntimeError(\"invalid result\")\n\nWIN_MOVE = {}\nfor c_idx in range(5):\n    winners = []\n    for u_idx in range(5):\n        if result_idx(u_idx, c_idx) == \"win\":\n            winners.append(u_idx)\n    WIN_MOVE[c_idx] = winners[0]\n\ndef rng_from_state(state):\n    while True:\n        yield state &amp; 0xF\n        for _ in range(4):\n            bit = (state ^ (state &gt;&gt; 3) ^ (state &gt;&gt; 7)) &amp; 1\n            state = (state &gt;&gt; 1) | (bit &lt;&lt; 63)\n\ndef step_deps(deps):\n    new = [set() for _ in range(64)]\n    tap = deps[0] ^ deps[3] ^ deps[7]\n    for i in range(63):\n        new[i] = deps[i + 1].copy()\n    new[63] = tap\n    return new\n\ndef one_rng_step_deps(deps_state):\n    out = deps_state[:4]\n    for _ in range(4):\n        deps_state = step_deps(deps_state)\n    return out, deps_state\n\nMAX_T = 200\ndeps_state = [ {i} for i in range(64) ]\nout_dep_nibbles = []\nfor t in range(MAX_T):\n    out_bits, deps_state = one_rng_step_deps(deps_state)\n    nibbles = set()\n    for bitset in out_bits:\n        for b in bitset:\n            nibbles.add(b // 4)\n    out_dep_nibbles.append(nibbles)\n\ndef recover_state_from_observations(allowed_residues, max_t_use=100):\n    T = min(max_t_use, len(allowed_residues))\n    domains = []\n    for i in range(16):\n        R = allowed_residues[i]\n        vals = [v for v in range(16) if (v % 5) in R]\n        if not vals:\n            raise RuntimeError(\"No values for nibble\", i)\n        domains.append(vals)\n\n    partial = [None] * 16\n    found_state = None\n    depN = out_dep_nibbles\n\n    def check_prefix(k):\n        state = 0\n        for i in range(k):\n            state |= (partial[i] &amp; 0xF) &lt;&lt; (4 * i)\n        rng_state = state\n        assigned_set = set(range(k))\n        for t in range(T):\n            if depN[t].issubset(assigned_set):\n                out_nib = rng_state &amp; 0xF\n                if (out_nib % 5) not in allowed_residues[t]:\n                    return False\n            for _ in range(4):\n                bit = (rng_state ^ (rng_state &gt;&gt; 3) ^ (rng_state &gt;&gt; 7)) &amp; 1\n                rng_state = (rng_state &gt;&gt; 1) | (bit &lt;&lt; 63)\n        return True\n\n    def dfs(i):\n        nonlocal found_state\n        if found_state is not None:\n            return\n        if i == 16:\n            state = 0\n            for j in range(16):\n                state |= (partial[j] &amp; 0xF) &lt;&lt; (4 * j)\n            rng_state = state\n            for t in range(T):\n                nib = rng_state &amp; 0xF\n                if (nib % 5) not in allowed_residues[t]:\n                    return\n                for _ in range(4):\n                    bit = (rng_state ^ (rng_state &gt;&gt; 3) ^ (rng_state &gt;&gt; 7)) &amp; 1\n                    rng_state = (rng_state &gt;&gt; 1) | (bit &lt;&lt; 63)\n            found_state = state\n            return\n        for v in domains[i]:\n            partial[i] = v\n            if check_prefix(i + 1):\n                dfs(i + 1)\n                if found_state is not None:\n                    return\n        partial[i] = None\n\n    dfs(0)\n    if found_state is None:\n        raise RuntimeError(\"State recovery failed\")\n    return found_state\n\ndef main():\n    s = socket.create_connection((HOST, PORT))\n    # ... (connect, play 100 rounds, recover state, win 200)\n    s.close()\n\nif __name__ == \"__main__\":\n    main()</code></pre>\n\n<p>The exploit wins all 200 rounds:</p>\n<pre><code>[+] Success! Won 200/200 rounds!\n[FLAG] gctf{y0u_4r3_7H3_TrUE_rN635u5_n0W_7rY_j3N5H1n_1Mp4C7}</code></pre>\n<p>Game over.</p>\n\n<p>By Roockbye</p>",
    "tags": [
      "crypto",
      "glacierctf2025",
      "LFSR",
      "RNG"
    ],
    "hash": "sha512:a3c7e1f09b42",
    "mitigations": [
      "Use cryptographically secure PRNGs (e.g. os.urandom, secrets module)",
      "Never use LFSRs for security-critical randomness",
      "Don't leak partial information about internal state to users",
      "Avoid games where predictability equals compromise"
    ],
    "date": "2025-12-03T11:58:00Z"
  },
  {
    "id": "tarsnap",
    "title": "Tarsnap",
    "category": "crypto",
    "difficulty": "hard",
    "summary": "HeroCTF – Compression side-channel attack (CRIME/BREACH style) on an encrypted TAR backup service to recover the flag character by character.",
    "content": "<p>Why do encrypted ZIPs exist but not encrypted TARs? Anyway, I made a 100% super secure online backup service because I'm truly paranoid.</p>\n<p>This challenge pretends to offer a \"super secure online encrypted tar archive service\".</p>\n<p>You can:</p>\n<pre><code>1. Add flag to encrypted archive\n2. Add your own file\n3. Export the encrypted archive</code></pre>\n<p>The server claims your archive is <strong>encrypted</strong>, so how could we ever recover the flag?</p>\n<p>The trick is that the encryption (ChaCha20) <strong>does not hide the size</strong> of the compressed data. And the compression algorithm leaks incredible information about the flag.</p>\n<p><strong>compression + encryption + attacker-controlled input = catastrophic leakage</strong></p>\n\n<h2>1 \u2013 How the server works internally</h2>\n<p>The server likely does something equivalent to this:</p>\n<pre><code>tar_data = build_tar(files)\ncompressed = zlib.compress(tar_data)\nencrypted = chacha20_encrypt(KEY, NONCE, compressed)\nreturn encrypted</code></pre>\n<p>Important details:</p>\n<ul>\n<li>The <strong>flag</strong> and <strong>our file</strong> are both stored inside the same TAR.</li>\n<li>The TAR is then <strong>compressed</strong>.</li>\n<li>Then the compressed result is <strong>encrypted</strong>.</li>\n<li><strong>ChaCha20 does NOT change the length</strong> of the data.</li>\n<li>The challenge shows us the <strong>hex length</strong> of the encrypted bytes.</li>\n</ul>\n<p>This means: The output size == the size of the compressed TAR.</p>\n<p>So: <strong>If compression behaves differently, the encrypted output size changes.</strong> This is the root vulnerability.</p>\n\n<h2>2 \u2013 Compression 101</h2>\n<p>Compression algorithms like DEFLATE (used by zlib) work by finding <strong>repeated patterns</strong> and replacing them with shorter references.</p>\n<p>Example:</p>\n<pre><code>Input:  ABCABCABC</code></pre>\n<p>The compressor first writes <code>ABC</code>, then notices the pattern repeats, so instead of writing the actual bytes again, it outputs:</p>\n<pre><code>(distance=3, length=3)\n(distance=3, length=3)</code></pre>\n<p>This drastically reduces the output size.</p>\n<p><strong>Key principle:</strong> The more the input contains repeated sequences, the more compression shrinks it.</p>\n\n<h2>3 \u2013 Where the vulnerability comes from</h2>\n<p>The server compresses <em>both</em> the secret flag and our controlled data <strong>together</strong> in the same stream.</p>\n<pre><code>tar = [flag.txt | guess.txt]\ncompressed = zlib.compress(tar)\nencrypted = chacha20(compressed)\nreturn encrypted_size</code></pre>\n<p>This is a <strong>fundamental mistake</strong>. Because now compression sees:</p>\n<ul>\n<li>SECRET: <code>Hero{5h0uld...}</code></li>\n<li>USER INPUT: <code>Hero{5h0uld...???</code></li>\n</ul>\n<p>If our input starts with the <strong>correct prefix</strong> of the flag:</p>\n<pre><code>Hero{5h0uld_h4v3</code></pre>\n<p>then compression will say: \"Hey, I've seen this before in the flag!\" \u2192 big compression gain \u2192 final size shrinks.</p>\n<p>If our guess is <strong>wrong</strong>:</p>\n<pre><code>Hero{XXXXXXXXXXXX</code></pre>\n<p>then compression finds fewer matches \u2192 size grows.</p>\n<p>Thus: By measuring the size of the encrypted output, we can tell if our guess matches the flag.</p>\n<p>This is called a <strong>compression side-channel attack</strong>. This class of bugs is real and dangerous:</p>\n<ul>\n<li><strong>CRIME</strong></li>\n<li><strong>BREACH</strong></li>\n<li><strong>TIME</strong></li>\n<li><strong>HEIST</strong></li>\n</ul>\n<p>All based on the exact same principle.</p>\n\n<h2>4 \u2013 Turning the leak into an oracle</h2>\n<p>We want to guess the next character of the flag. We know the flag begins with <code>Hero{</code>. Let's try guessing the next character.</p>\n<p>We test input = \"Hero{a}\". We send a file whose content contains many repetitions of:</p>\n<pre><code>salt1 + \"Hero{a\"\nsalt2 + \"Hero{a\"\n...\nsaltN + \"Hero{a\"</code></pre>\n<p>We add the flag (option 1), add our file (option 2), then export (option 3). We note the encrypted length. Then test \"Hero{b}\", \"Hero{c}\", \"Hero{0}\", \"Hero{_}\"\u2026 etc.</p>\n<p>For each candidate character <code>c</code>, we calculate: <code>length(compress(flag + our_payload \"prefix+c\"))</code></p>\n<p>The candidate <strong>producing the smallest size</strong> is the correct next character. We append it to our known prefix and repeat.</p>\n\n<h2>5 \u2013 Amplifying the leakage</h2>\n<p>The difference in size between correct and incorrect guesses can be small (sometimes 1\u20133 bytes). To make the detection reliable, we amplify the effect:</p>\n\n<h3>Many repetitions (\"CHUNKS\")</h3>\n<p>Instead of writing <code>prefix + c</code>, we send:</p>\n<pre><code>salt1 || prefix+c\nsalt2 || prefix+c\n...\nsalt800 || prefix+c</code></pre>\n<p>The repetition of \"prefix+c\" strongly boosts compression if <code>c</code> is correct.</p>\n\n<h3>Random salts</h3>\n<p>We prepend every repetition with random bytes to avoid unintended compression on other parts of the TAR structure. This ensures only the <strong>prefix+c</strong> region is the repeated pattern the compressor sees.</p>\n\n<h3>Multiple measurements (SAMPLES)</h3>\n<p>Each guess is tested multiple times because the server may introduce noise. We take the <strong>minimum</strong> or <strong>median</strong> to smooth randomness.</p>\n\n<h3>Narrowing down TOP_K</h3>\n<p>We take only the 5 best candidates (smallest size) and re-test them to select the true best.</p>\n\n<h2>6 \u2013 Exploitation script</h2>\n<p>A simplified version of the final exploit:</p>\n<pre><code>payload = b\"\".join(s + (known_prefix + candidate)\n                   for s in salts)\n\nct_len = query_length(payload.hex().encode())</code></pre>\n<p>This is repeated for all characters in the charset:</p>\n<pre><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_{}-</code></pre>\n<p>Once the character that minimizes size is found, we append it and move to the next one. The prefix grows like:</p>\n<pre><code>Hero{5\nHero{5h\nHero{5h0\nHero{5h0u\n...\nHero{5h0uld_h4v3_u53d_3ncryp7_7h3n_c0mpr355_1n5734d}</code></pre>\n<p>Exactly like solving a crossword puzzle where the server reveals \"hotter/colder\" based on compression.</p>\n\n<h3>Full exploit script</h3>\n<pre><code>#!/usr/bin/env python3\nimport os, random, string\nfrom pwn import context, remote\n\nHOST = \"crypto.heroctf.fr\"\nPORT = 9002\nPREFIX = b\"Hero{\"\nCHARSET = string.ascii_letters + string.digits + \"_{}-\"\nCHUNKS = 800\nSALT_LEN = 8\nSAMPLES = 5\nTOP_K = 5\ncontext.log_level = \"error\"\n\ndef build_payload(prefix, salts):\n    return b\"\".join(s + prefix for s in salts)\n\nclass Oracle:\n    def __init__(self):\n        self.conn = remote(HOST, PORT, timeout=10)\n\n    def query_length(self, hexdata):\n        r = self.conn\n        r.sendlineafter(b\"&gt; \", b\"1\")\n        r.sendlineafter(b\"&gt; \", b\"2\")\n        r.sendlineafter(b\"Filename: \", b\"a\")\n        r.sendlineafter(b\"Content: \", hexdata)\n        r.sendlineafter(b\"&gt; \", b\"3\")\n        line = r.recvline(timeout=5)\n        while line and b\"Encrypted content:\" not in line:\n            line = r.recvline(timeout=5)\n        cipher_hex = line.split(b\":\", 1)[1].strip()\n        return len(cipher_hex) // 2\n\ndef main():\n    salts = [os.urandom(SALT_LEN) for _ in range(CHUNKS)]\n    oracle = Oracle()\n    current = PREFIX\n    charset_bytes = [c.encode() for c in CHARSET]\n\n    while True:\n        scores = []\n        for ch in charset_bytes:\n            guess = current + ch\n            payload = build_payload(guess, salts)\n            length = oracle.query_length(payload.hex().encode())\n            scores.append((length, ch, payload.hex().encode()))\n\n        scores.sort(key=lambda x: x[0])\n        best = None\n        for l, ch, hx in scores[:TOP_K]:\n            lengths = [l]\n            for _ in range(SAMPLES - 1):\n                lengths.append(oracle.query_length(hx))\n            score = min(lengths)\n            if best is None or score &lt; best[0]:\n                best = (score, ch)\n\n        current += best[1]\n        print(f\"[+] {current.decode()}\")\n        if best[1] == b\"}\":\n            break\n\nif __name__ == \"__main__\":\n    main()</code></pre>\n\n<p>The final recovered secret was:</p>\n<pre><code>Hero{5h0uld_h4v3_u53d_3ncryp7_7h3n_c0mpr355_1n5734d}</code></pre>\n\n<p>By Roockbye</p>",
    "tags": [
      "crypto",
      "heroctf",
      "compression",
      "side-channel",
      "CRIME"
    ],
    "hash": "sha512:d8f2a1c7e930",
    "mitigations": [
      "Never compress then encrypt user-controlled data alongside secrets (CRIME/BREACH)",
      "Use authenticated encryption with padding to mask exact plaintext lengths",
      "Separate secret and attacker-controlled data into different compression contexts",
      "Add random padding before encryption to obscure compressed size"
    ],
    "date": "2025-12-03T12:30:00Z"
  },
  {
    "id": "mutlock",
    "title": "MuTLock",
    "category": "crypto",
    "difficulty": "medium",
    "summary": "HTB Uni CTF 2024 – Reversing a timestamp-seeded polyalphabetic + XOR cipher with dynamic key generation to recover the encrypted flag.",
    "content": "<p>The Frontier Board encrypts their secrets using a system tied to the ever-shifting cosmic cycles, woven with patterns that seem random to the untrained eye. To outwit their defenses, you'll need to decipher the hidden rhythm of time and unlock the truth buried in their encoded transmissions.</p>\n\n<h2>1 – Overview</h2>\n<p>We're given two files:</p>\n<ul>\n<li><strong>source.py</strong> – the encryption script</li>\n<li><strong>output.txt</strong> – the encrypted flag</li>\n</ul>\n<p>The script performs a multi-layered encryption based on <strong>dynamically generated keys</strong>. Let's break down each function.</p>\n\n<h2>2 – Key generation: <code>generate_key(seed, length=16)</code></h2>\n<pre><code>def generate_key(seed, length=16):\n    random.seed(seed)\n    key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))\n    return key</code></pre>\n<p>Generates a <strong>deterministic</strong> random key from a seed. Same seed → same key every time. The key is a 16-character string of letters and digits.</p>\n<p><strong>Critical weakness:</strong> if we know the seed, we know the key.</p>\n\n<h2>3 – Polyalphabetic cipher: <code>polyalphabetic_encrypt(plaintext, key)</code></h2>\n<pre><code>def polyalphabetic_encrypt(plaintext, key):\n    key_length = len(key)\n    ciphertext = []\n    for i, char in enumerate(plaintext):\n        key_char = key[i % key_length]\n        encrypted_char = chr((ord(char) + ord(key_char)) % 256)\n        ciphertext.append(encrypted_char)\n    return base64.b64encode(''.join(ciphertext).encode()).decode()</code></pre>\n<p>For each character of the plaintext:</p>\n<ol>\n<li>Take the corresponding key character (cycling through the key)</li>\n<li>Add both ASCII values <strong>mod 256</strong></li>\n<li>Encode the result in <strong>base64</strong></li>\n</ol>\n<p>This is a classic <strong>Vigenère-like cipher</strong> extended to the full byte range.</p>\n\n<h2>4 – XOR layer: <code>xor_cipher(text, key)</code></h2>\n<pre><code>def xor_cipher(text, key):\n    return bytes([ord(c) ^ key for c in text])</code></pre>\n<p>Simple single-byte XOR on each character. XOR is its own inverse: applying the same XOR key twice recovers the original text.</p>\n\n<h2>5 – Timestamp-based key selection: <code>get_timestamp_based_keys()</code></h2>\n<pre><code>def get_timestamp_based_keys():\n    timestamp = int(time.time())\n    if timestamp % 2 == 0:\n        key_seed = random.randint(1, 1000)\n        xor_key = 42\n    else:\n        key_seed = 42\n        xor_key = random.randint(1, 255)\n    return key_seed, xor_key</code></pre>\n<p>The encryption path depends on the <strong>parity of the current timestamp</strong>:</p>\n<ul>\n<li><strong>Even timestamp:</strong> random seed (1–1000), fixed XOR key = 42</li>\n<li><strong>Odd timestamp:</strong> fixed seed = 42, random XOR key (1–255)</li>\n</ul>\n<p>This introduces dynamic behavior, but the key spaces are <strong>extremely small</strong>.</p>\n\n<h2>6 – Full encryption pipeline</h2>\n<p>The flag is <strong>split in half</strong>. Each half goes through:</p>\n<ol>\n<li>Generate <code>key_seed</code> and <code>xor_key</code> from timestamp</li>\n<li>Generate polyalphabetic key from <code>key_seed</code></li>\n<li>Encrypt with polyalphabetic cipher → base64 output</li>\n<li>XOR the base64 string with <code>xor_key</code></li>\n<li>Convert to hex</li>\n</ol>\n<p>The two hex-encoded halves are written to <code>output.txt</code>.</p>\n\n<h2>7 – The attack: reversing the pipeline</h2>\n<p>To decrypt, we reverse every step:</p>\n<ol>\n<li><strong>Hex → bytes</strong></li>\n<li><strong>XOR with the same key</strong> (XOR is self-inverse)</li>\n<li><strong>Base64 decode</strong></li>\n<li><strong>Reverse the polyalphabetic cipher:</strong> subtract key characters mod 256</li>\n</ol>\n<p>The only unknowns are <code>key_seed</code> and <code>xor_key</code>. But their ranges are tiny:</p>\n<ul>\n<li><strong>Even path:</strong> key_seed ∈ [1, 1000], xor_key = 42 → <strong>1000 possibilities</strong></li>\n<li><strong>Odd path:</strong> key_seed = 42, xor_key ∈ [1, 255] → <strong>255 possibilities</strong></li>\n</ul>\n<p>Total search space: <strong>1255 combinations</strong>. Trivially brute-forceable.</p>\n\n<h2>8 – Brute-force strategy</h2>\n<p>For each half of the ciphertext:</p>\n<pre><code># Try even-timestamp path\nfor seed in range(1, 1001):\n    key = generate_key(seed)\n    result = polyalphabetic_decrypt(xor_decrypt(hex_half, 42), key)\n    if is_printable(result):\n        candidates.append(result)\n\n# Try odd-timestamp path\nfor xor_k in range(1, 256):\n    key = generate_key(42)\n    result = polyalphabetic_decrypt(xor_decrypt(hex_half, xor_k), key)\n    if is_printable(result):\n        candidates.append(result)</code></pre>\n<p>We check if the decrypted output contains only printable ASCII. This filters out wrong keys instantly.</p>\n\n<h2>9 – Result</h2>\n<p>The decrypted flag:</p>\n<pre><code>HTB{timestamp_based_encryption_is_so_secure_i_promise}</code></pre>\n\n<h2>Why this is insecure</h2>\n<ul>\n<li><strong>Tiny key space:</strong> 1255 total combinations is instantaneously brute-forceable</li>\n<li><strong>Deterministic PRNG:</strong> Python's <code>random</code> module with a known seed is fully predictable</li>\n<li><strong>XOR with single byte:</strong> provides zero real security, trivially reversible</li>\n<li><strong>Polyalphabetic cipher:</strong> a 16th-century technique, broken long ago</li>\n<li><strong>Timestamp dependency:</strong> doesn't add entropy, just branches between two weak paths</li>\n</ul>\n<p><strong>Lesson:</strong> Stacking weak ciphers doesn't make strong encryption. Use modern primitives like AES-GCM or ChaCha20-Poly1305.</p>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "crypto",
      "htb-uni-2024",
      "polyalphabetic",
      "XOR",
      "brute-force"
    ],
    "hash": "sha512:e4b7f2d8c153",
    "mitigations": [
      "Never use Python's random module for cryptographic key generation – use secrets or os.urandom",
      "Avoid timestamp-based key selection with tiny key spaces",
      "Use modern authenticated encryption (AES-GCM, ChaCha20-Poly1305) instead of custom ciphers",
      "Single-byte XOR and polyalphabetic ciphers offer no real security"
    ],
    "date": "2024-12-14T10:00:00Z"
  },
  {
    "id": "drunk-christmas",
    "title": "Drunk Christmas",
    "category": "crypto",
    "difficulty": "medium",
    "summary": "HackDay CTF – Exploiting a flawed encrypted file-sharing service where the same keystream encrypts user input and the flag, enabling a byte-by-byte chosen-plaintext attack.",
    "content": "<p>A \"secure file sharing\" service lets you upload a file alongside the secret flag, compresses them into a ZIP, and returns an encrypted archive. The catch: the encryption applies the <strong>same keystream</strong> to both your input and the flag — meaning identical plaintext bytes produce identical ciphertext bytes.</p>\n<p>This is a textbook <strong>chosen-plaintext attack</strong> on a stream cipher with a reused keystream.</p>\n\n<h2>1 – How the service works</h2>\n<p>The server exposes a simple web interface:</p>\n<ol>\n<li>You upload a file (<code>input.txt</code>)</li>\n<li>The server bundles it with <code>flag.txt</code> into a ZIP</li>\n<li>The ZIP is encrypted and returned for download</li>\n</ol>\n<p>Inside the encrypted ZIP, we find:</p>\n<ul>\n<li><code>input.txt.enc</code> – our input, encrypted</li>\n<li><code>flag.txt.enc</code> – the flag, encrypted</li>\n</ul>\n<p>Both files are encrypted with the <strong>same key/keystream</strong> in the same operation.</p>\n\n<h2>2 – The vulnerability: keystream reuse</h2>\n<p>The encryption works byte-by-byte. For position <code>i</code>:</p>\n<pre><code>input.txt.enc[i] = encrypt(input.txt[i], keystream[i])\nflag.txt.enc[i]  = encrypt(flag.txt[i],  keystream[i])</code></pre>\n<p>Since both use the <strong>same keystream byte at position i</strong>:</p>\n<ul>\n<li>If <code>input.txt[i] == flag.txt[i]</code> → then <code>input.txt.enc[i] == flag.txt.enc[i]</code></li>\n<li>If the bytes differ → the encrypted bytes differ</li>\n</ul>\n<p>This gives us a <strong>perfect oracle</strong>: we can test any character at any position and instantly know if it matches the flag.</p>\n\n<h2>3 – The attack: byte-by-byte recovery</h2>\n<p>We know the flag starts with <code>HACKDAY{</code>. For each unknown position:</p>\n<ol>\n<li>Try every printable character <code>c</code></li>\n<li>Build a test string: <code>known_prefix + c + padding</code> (padded to 50 chars)</li>\n<li>Upload it to the server</li>\n<li>Download and extract the encrypted ZIP</li>\n<li>Compare <code>input.txt.enc[i]</code> vs <code>flag.txt.enc[i]</code></li>\n<li>If they match → <code>c</code> is the correct character</li>\n<li>Append <code>c</code> to the known prefix, move to the next position</li>\n</ol>\n\n<h2>4 – Exploit script</h2>\n<pre><code>import os, requests, zipfile\nfrom string import printable\n\nurl = \"http://challenges.hackday.fr:53073\"\nflag = \"HACKDAY{\"\n\ndef write_input(data):\n    with open(\"input.txt\", \"w\") as f:\n        f.write(data)\n\ndef upload_file():\n    with open(\"input.txt\", 'rb') as file:\n        files = {'file': (\"input.txt\", file)}\n        response = requests.post(url + \"/secure_sharing\", files=files)\n        try:\n            return response.text.split(\"\\n\")[-4].split('\"')[1]\n        except:\n            return \"\"\n\ndef download_file(filename):\n    response = requests.get(url + filename)\n    with open(filename.split(\"/\")[2], \"wb\") as f:\n        f.write(response.content)\n\ndef extract_zip(filename):\n    with zipfile.ZipFile(filename.split(\"/\")[2], 'r') as zip_ref:\n        zip_ref.extractall(\"extracted\")\n\ndef check_chars(index):\n    with open(\"extracted/input.txt.enc\", \"rb\") as f:\n        input_enc = f.read()\n    with open(\"extracted/flag.txt.enc\", \"rb\") as f:\n        flag_enc = f.read()\n    return input_enc[index] == flag_enc[index]\n\nwhile len(flag) < 50:\n    for c in printable:\n        input_text = flag + c + \"A\" * (50 - len(flag) - 1)\n        write_input(input_text)\n        filename = \"\"\n        while filename == \"\":\n            filename = upload_file()\n        download_file(filename)\n        extract_zip(filename)\n        os.remove(filename.split(\"/\")[2])\n\n        if check_chars(len(flag)):\n            flag += c\n            print(flag)\n            break</code></pre>\n\n<h2>5 – Step-by-step execution</h2>\n<p>The script progressively reconstructs the flag:</p>\n<pre><code>HACKDAY{S\nHACKDAY{Si\nHACKDAY{Sim\nHACKDAY{Simp\nHACKDAY{Simpl\nHACKDAY{Simple\n...\nHACKDAY{Simple_Secrets_For_Weak_Cipher_1134567892}</code></pre>\n<p>Each character is confirmed by the encryption oracle — no guessing involved.</p>\n\n<h2>6 – Result</h2>\n<p>The recovered flag:</p>\n<pre><code>HACKDAY{Simple_Secrets_For_Weak_Cipher_1134567892}</code></pre>\n\n<h2>Why this is insecure</h2>\n<ul>\n<li><strong>Keystream reuse</strong> – encrypting two files with the same keystream allows direct byte comparison</li>\n<li><strong>Chosen-plaintext oracle</strong> – the attacker controls one of the encrypted inputs</li>\n<li><strong>No authentication</strong> – the server blindly encrypts whatever you send alongside the secret</li>\n<li><strong>Deterministic encryption per position</strong> – identical plaintext bytes always produce identical ciphertext bytes</li>\n</ul>\n<p><strong>Lesson:</strong> Never encrypt attacker-controlled data alongside secrets using the same keystream. Use unique keys/nonces per file, and never expose encrypted outputs of chosen plaintexts.</p>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "crypto",
      "hackday",
      "chosen-plaintext",
      "stream-cipher",
      "keystream-reuse"
    ],
    "hash": "sha512:c9d4e7a2f861",
    "mitigations": [
      "Never reuse a keystream to encrypt multiple files – use unique nonces/IVs per encryption",
      "Don't let users encrypt chosen plaintext alongside secrets",
      "Use authenticated encryption (AES-GCM) to prevent ciphertext manipulation",
      "Encrypt each file independently with separate keys"
    ],
    "date": "2025-03-25T09:00:00Z"
  },
  {
    "id": "edgar-loses-his-calm",
    "title": "Edgar loses his calm",
    "category": "system",
    "difficulty": "init",
    "summary": "HackDay CTF – OSINT challenge: chaining public information (architect birthplace → football club → racist incident → player Twitter handle) to compute an MD5 hash flag.",
    "content": "<p>Edgar is furious about a football player. Our job: figure out who, find their Twitter handle, and compute the MD5 hash. Pure OSINT — no exploits, just research.</p>\n\n<h2>1 – Parsing the clues</h2>\n<p>The challenge description gives us a chain of hints:</p>\n<ul>\n<li>A famous <strong>architect</strong> named <strong>Renzo Piano</strong></li>\n<li>A <strong>football club</strong> in Renzo Piano's <strong>hometown</strong></li>\n<li>A <strong>black player</strong> who recently joined this club</li>\n<li>This player was <strong>targeted by racism</strong></li>\n<li>We need the player's <strong>Twitter handle</strong> and its <strong>MD5 hash</strong></li>\n</ul>\n<p>Let's follow the breadcrumbs.</p>\n\n<h2>2 – Renzo Piano → Genoa</h2>\n<p>A quick search reveals that <strong>Renzo Piano</strong> (architect of the Centre Pompidou, The Shard, etc.) was born in <strong>Genoa, Italy</strong>.</p>\n<p>This is our geographic anchor.</p>\n\n<h2>3 – Football club in Genoa</h2>\n<p>Genoa's most famous football club is <strong>Genoa CFC</strong> (Genoa Cricket and Football Club), founded in 1893 — one of the oldest in Italy. They compete in <strong>Serie A</strong>.</p>\n\n<h2>4 – Recent black player + racism incidents</h2>\n<p>Cross-referencing recent Genoa CFC transfers with racism incidents in Italian football leads us to <strong>Mario Balotelli</strong>.</p>\n<p>Balotelli:</p>\n<ul>\n<li>Joined <strong>Genoa CFC</strong> as a recent transfer</li>\n<li>Italian-born player of Ghanaian descent</li>\n<li>Has been a <strong>repeated target of racist abuse</strong> throughout his career in Serie A</li>\n<li>Highly publicized incidents including monkey chants and banana throwing</li>\n</ul>\n<p>He matches every criteria in the challenge description.</p>\n\n<h2>5 – Finding the Twitter handle</h2>\n<p>Mario Balotelli's verified Twitter account:</p>\n<pre><code>@FinallyMario</code></pre>\n<p>This is easy to confirm via a simple Google search or directly on Twitter/X.</p>\n\n<h2>6 – Computing the MD5 hash</h2>\n<p>The challenge asks for the MD5 hash of the Twitter handle <strong>in lowercase</strong>:</p>\n<pre><code>import hashlib\n\nhandle = \"@FinallyMario\"\nmd5 = hashlib.md5(handle.lower().encode()).hexdigest()\nprint(md5)\n# → 98d62c513ab6e0e7de0817613a360287</code></pre>\n\n<h2>7 – Result</h2>\n<p>The flag:</p>\n<pre><code>HACKDAY{98d62c513ab6e0e7de0817613a360287}</code></pre>\n\n<h2>OSINT methodology recap</h2>\n<p>The full chain:</p>\n<ol>\n<li><strong>Renzo Piano</strong> → born in <strong>Genoa</strong></li>\n<li><strong>Genoa</strong> → football club <strong>Genoa CFC</strong></li>\n<li><strong>Genoa CFC + black player + racism</strong> → <strong>Mario Balotelli</strong></li>\n<li><strong>Balotelli Twitter</strong> → <strong>@FinallyMario</strong></li>\n<li><strong>MD5(\"@finallymario\")</strong> → <code>98d62c513ab6e0e7de0817613a360287</code></li>\n</ol>\n<p>Each step narrows the search space until only one answer remains. Classic OSINT pivot chain.</p>\n\n<h2>Key takeaways</h2>\n<ul>\n<li><strong>OSINT is about connecting dots</strong> — each clue leads to the next</li>\n<li><strong>Cross-reference sources</strong>: Wikipedia, Transfermarkt, Twitter, news articles</li>\n<li><strong>Pay attention to wording</strong>: \"hometown\", \"recently joined\", \"black player\" are all filters</li>\n<li><strong>Verify before hashing</strong>: lowercase vs uppercase, with/without @ — details matter</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "osint",
      "hackday",
      "social-media",
      "MD5",
      "reconnaissance"
    ],
    "hash": "sha512:b3a8d6f1e527",
    "mitigations": [
      "Limit publicly available personal information to reduce OSINT attack surface",
      "Be aware that cross-referencing public data sources can reveal sensitive connections",
      "Use privacy settings on social media to restrict discoverability",
      "Organizations should audit what information is publicly accessible about their members"
    ],
    "date": "2025-03-25T09:16:00Z"
  },
  {
    "id": "find-eve-1",
    "title": "Find Eve 1",
    "category": "crypto",
    "difficulty": "medium",
    "summary": "HackDay CTF – Two-layer decryption: AES-256-CBC with a Neuromancer-themed key, followed by ASCII85 (RFC 1924) decoding to reveal the hidden flag.",
    "content": "<p>We're given a mysterious file called <code>MessageSecret</code> with no extension. The goal: peel back two layers of encoding to find the flag hidden inside.</p>\n\n<h2>1 – File analysis</h2>\n<p>First observations about the file:</p>\n<ul>\n<li><strong>208 bytes</strong> — a perfect multiple of 16</li>\n<li><strong>High entropy</strong> — the data looks random, no discernible patterns</li>\n<li><strong>No file extension</strong> — no hints about the format</li>\n</ul>\n<p>208 = 13 × 16. This is a strong indicator of <strong>AES block cipher encryption</strong>, which operates on 16-byte (128-bit) blocks.</p>\n<p>High entropy + block-aligned size = almost certainly encrypted data.</p>\n\n<h2>2 – Finding the decryption parameters</h2>\n<p>AES-256-CBC requires:</p>\n<ul>\n<li>A <strong>password/key</strong></li>\n<li>A <strong>salt</strong> (for key derivation)</li>\n</ul>\n\n<h3>The key: Neuromancer reference</h3>\n<p>The challenge hints at a famous cyberpunk novel. <strong>Wintermute</strong> is the AI antagonist in William Gibson's <em>Neuromancer</em> (1984) — this is our decryption key.</p>\n\n<h3>The salt: derived from the key</h3>\n<p>The salt is the first 16 hex characters of SHA-256(\"Wintermute\"):</p>\n<pre><code>$ echo -n \"Wintermute\" | sha256sum\ndfd05592762aa2ac733a8b185956f6cb55a58949...\n\nSalt = dfd05592762aa2ac</code></pre>\n\n<h2>3 – Layer 1: AES-256-CBC decryption</h2>\n<p>With key and salt in hand:</p>\n<pre><code>openssl enc -d -aes-256-cbc -salt -pbkdf2 \\\n  -S dfd05592762aa2ac \\\n  -in MessageSecret \\\n  -out MessageDecrypt \\\n  -k Wintermute</code></pre>\n<p>Breakdown:</p>\n<ul>\n<li><code>-d</code> — decrypt mode</li>\n<li><code>-aes-256-cbc</code> — AES with 256-bit key in CBC mode</li>\n<li><code>-pbkdf2</code> — password-based key derivation (PBKDF2)</li>\n<li><code>-S</code> — explicit salt value</li>\n<li><code>-k</code> — passphrase</li>\n</ul>\n<p>The decrypted output is not plaintext yet — it's another layer of encoding:</p>\n<pre><code>E-o$#PitX$EFeiIY-}K6Wgv8DWpZU8VRRrhAaE{iE($I#E(%#?b1Wc9A\naZ4GWo=?*ax5TuZ*?GOVRmI8bZ;PVb#x$MAV@(&amp;OGH6gdvY^GAZkEEY\ncn@}E-o$#E-o$#Ng!xpc4Z)RZy;=CVRmI8d2e+rAa...</code></pre>\n\n<h2>4 – Layer 2: ASCII85 decoding</h2>\n<p>The character set and structure match <strong>ASCII85</strong> (also called Base85), defined in <strong>RFC 1924</strong>.</p>\n<p>How ASCII85 works:</p>\n<ul>\n<li>Groups of <strong>4 bytes</strong> (32 bits) are encoded as <strong>5 ASCII characters</strong></li>\n<li>Each character maps to a value 0–84, offset by ASCII 33</li>\n<li>Ratio: 4:5 — more compact than Base64's 3:4</li>\n</ul>\n<p>Decoding the ASCII85 string reveals the plaintext:</p>\n<pre><code>Okay, I'll be there at 5 p.m.\nYes, I remember, you have to put a HACKDAY{r3D j@Ck37}...\nI have to leave you, we'll meet in front of the clock.</code></pre>\n\n<h2>5 – Result</h2>\n<p>The flag:</p>\n<pre><code>HACKDAY{r3D j@Ck37}</code></pre>\n<p><em>r3D j@Ck37</em> = \"Red Jacket\" in leet speak — a classic cyberpunk reference.</p>\n\n<h2>Summary of the decryption chain</h2>\n<ol>\n<li><strong>MessageSecret</strong> (208 bytes, encrypted)</li>\n<li>↓ AES-256-CBC + PBKDF2 (key: Wintermute, salt: SHA256 prefix)</li>\n<li><strong>ASCII85-encoded text</strong></li>\n<li>↓ Base85 decoding</li>\n<li><strong>Plaintext with flag</strong></li>\n</ol>\n\n<h2>Key takeaways</h2>\n<ul>\n<li><strong>File size analysis</strong> — multiples of 16 suggest block cipher encryption</li>\n<li><strong>High entropy = likely encrypted</strong> — use tools like <code>ent</code> or <code>binwalk</code> to assess</li>\n<li><strong>Cultural references matter in CTFs</strong> — Neuromancer/Wintermute is a common password theme</li>\n<li><strong>Multi-layered encoding</strong> — always check if decrypted output is itself encoded</li>\n<li><strong>ASCII85/Base85</strong> — less common than Base64 but recognizable by its character set</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "crypto",
      "hackday",
      "AES",
      "ASCII85",
      "multi-layer"
    ],
    "hash": "sha512:f7c2d9a4b638",
    "mitigations": [
      "Use strong, non-guessable passwords – cultural references are easily brute-forced",
      "Derive salts independently from the key to prevent correlated attacks",
      "Multi-layered encoding is not security – encoding != encryption",
      "Protect encrypted files with integrity checks (HMAC or authenticated encryption)"
    ],
    "date": "2025-03-25T09:13:00Z"
  },
  {
    "id": "no-music-stego",
    "title": "It says a lot when there is no music",
    "category": "system",
    "difficulty": "init",
    "summary": "HackDay CTF – Audio steganography: extracting ASCII-encoded data hidden in the silent trailing samples of a WAV file.",
    "content": "<p>A suspicious WAV file and a cryptic title: <em>\"It says a lot when there is no music.\"</em> The hint is clear — the secret hides where there's <strong>silence</strong>.</p>\n\n<h2>1 – Initial analysis</h2>\n<p>Opening the file reveals:</p>\n<ul>\n<li><strong>13,641,806 total samples</strong></li>\n<li>The audio plays normally for the first ~13.6M samples</li>\n<li>The last <strong>800 samples</strong> are suspicious: mostly zeros, then non-zero values at the very end</li>\n</ul>\n<p>The title says it all: the message is hidden <strong>in the silence</strong> — the part where there's no music.</p>\n\n<h2>2 – Isolating the hidden data</h2>\n<p>We skip past the actual audio and focus on the trailing samples:</p>\n<pre><code>from scipy.io import wavfile\n\nsample_rate, data = wavfile.read('suspicious_audio.wav')\n\n# If stereo, keep only one channel\nif len(data.shape) > 1:\n    data = data[:, 0]\n\n# Skip past the audio to the silent region\ndata = data[13641006:]\nprint(data)</code></pre>\n<p>Output: hundreds of zeros followed by a sequence of meaningful numbers:</p>\n<pre><code>[0 0 0 0 ... 0 0 34 65 32 108 111 116 32 119 104 101\n 110 32 116 104 101 114 101 32 105 115 32 110 111 32\n 109 117 115 105 99 34 46 32 72 101 114 101 32 105\n 115 32 121 111 117 114 32 102 108 97 103 32 58 32\n 72 65 67 75 68 65 89 123 77 97 115 116 51 114 95\n 48 102 95 87 52 118 40 101 115 41 125]</code></pre>\n\n<h2>3 – Waveform visualization</h2>\n<p>Plotting the trailing data with matplotlib confirms the pattern: a flat line of zeros, then a sharp spike of non-zero values at the very end.</p>\n<p>These non-zero values are all in the <strong>printable ASCII range</strong> (32–125). That's not audio data — it's text.</p>\n\n<h2>4 – ASCII conversion</h2>\n<p>Converting the non-zero sample values to characters:</p>\n<pre><code>values = [34, 65, 32, 108, 111, 116, 32, 119, 104, 101,\n  110, 32, 116, 104, 101, 114, 101, 32, 105, 115, 32,\n  110, 111, 32, 109, 117, 115, 105, 99, 34, 46, 32,\n  72, 101, 114, 101, 32, 105, 115, 32, 121, 111, 117,\n  114, 32, 102, 108, 97, 103, 32, 58, 32, 72, 65, 67,\n  75, 68, 65, 89, 123, 77, 97, 115, 116, 51, 114, 95,\n  48, 102, 95, 87, 52, 118, 40, 101, 115, 41, 125]\n\nmessage = ''.join(chr(v) for v in values)\nprint(message)</code></pre>\n<p>Output:</p>\n<pre><code>\"A lot when there is no music\". Here is your flag : HACKDAY{Mast3r_0f_W4v(es)}</code></pre>\n\n<h2>5 – Result</h2>\n<p>The flag:</p>\n<pre><code>HACKDAY{Mast3r_0f_W4v(es)}</code></pre>\n\n<h2>Alternative approach</h2>\n<p>The same result can be obtained in one command using <code>strings</code>:</p>\n<pre><code>strings -e b suspicious_audio.wav</code></pre>\n<p>The <code>-e b</code> flag tells <code>strings</code> to look for 16-bit big-endian encoded strings, which catches the embedded ASCII data directly.</p>\n\n<h2>How the steganography works</h2>\n<p>The technique is simple but effective:</p>\n<ol>\n<li>Take a normal audio file</li>\n<li>Append silence (zero samples) after the audio ends</li>\n<li>Embed ASCII character codes as <strong>raw sample values</strong> in the silent region</li>\n<li>Audio players ignore the trailing silence — you hear nothing unusual</li>\n</ol>\n<p>The values (34–125) are tiny compared to normal audio amplitudes (thousands), so even if played back they'd be inaudible.</p>\n\n<h2>Key takeaways</h2>\n<ul>\n<li><strong>Check the silence</strong> — trailing zeros in audio files can hide data</li>\n<li><strong>Sample values ARE data</strong> — each audio sample is just a number, perfect for hiding messages</li>\n<li><strong>Visualization helps</strong> — plotting the waveform reveals anomalies instantly</li>\n<li><strong>Multiple tools</strong> — Python (scipy/matplotlib) for analysis, <code>strings</code> for quick checks, Audacity for visual inspection</li>\n<li><strong>The title is always a clue</strong> in CTF challenges</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "steganography",
      "hackday",
      "audio",
      "WAV",
      "forensics"
    ],
    "hash": "sha512:a1e5c8d3f972",
    "mitigations": [
      "Strip trailing silence from audio files before distribution",
      "Use integrity checks (hashes) to detect file tampering",
      "Scan uploaded audio files for anomalous trailing data",
      "Monitor for unexpected data patterns in media file metadata and samples"
    ],
    "date": "2025-03-25T09:10:00Z"
  },
  {
    "id": "mona-lsb",
    "title": "Mona LSB",
    "category": "system",
    "difficulty": "init",
    "summary": "HackDay CTF – LSB steganography: extracting a flag hidden in the least significant bits of a WAV file's raw bytes using bitwise extraction and ASCII conversion.",
    "content": "<p>The file is called <code>wmremona_is_you_here.wav</code> and the challenge title mentions <strong>LSB</strong> — Least Significant Bit. The technique is spelled out for us: extract the LSB of each byte and reconstruct the hidden message.</p>\n\n<h2>1 – What is LSB steganography?</h2>\n<p>Every byte has 8 bits. The <strong>least significant bit</strong> (rightmost) carries the smallest value — flipping it changes the byte by at most 1.</p>\n<p>In audio/image files, changing the LSB of each sample is <strong>imperceptible</strong> to human senses. But those bits can encode an entirely separate message.</p>\n<p>The idea:</p>\n<ol>\n<li>Take each byte of the file</li>\n<li>Extract bit 0 (<code>byte &amp; 1</code>)</li>\n<li>Group every 8 extracted bits into a new byte</li>\n<li>Convert to ASCII → hidden message</li>\n</ol>\n\n<h2>2 – The extraction script</h2>\n<pre><code>import re\n\ndef lsb_extract(file_path):\n    with open(file_path, 'rb') as f:\n        data = f.read()\n\n    # Extract LSB of each byte\n    lsb_bits = ''.join(str(byte &amp; 1) for byte in data)\n\n    # Group into 8-bit chunks\n    bytes_list = [lsb_bits[i:i+8] for i in range(0, len(lsb_bits), 8)]\n\n    # Convert to printable ASCII\n    hidden = ''\n    for b in bytes_list:\n        if len(b) == 8:\n            c = chr(int(b, 2))\n            if 32 &lt;= ord(c) &lt;= 126:\n                hidden += c\n\n    # Search for flag pattern\n    match = re.search(r'HACKDAY\\{.*?\\}', hidden)\n    if match:\n        print(\"Flag:\", match.group(0))\n    else:\n        print(\"Hidden text:\", hidden[:500])\n\n    return hidden\n\nlsb_extract('wmremona_is_you_here.wav')</code></pre>\n\n<h2>3 – How it works step by step</h2>\n<ol>\n<li><strong>Read raw bytes</strong> — open the WAV file in binary mode</li>\n<li><strong>Bitwise AND</strong> — <code>byte &amp; 1</code> isolates the LSB of each byte</li>\n<li><strong>Reconstruct bytes</strong> — every 8 LSBs form a new byte (e.g., <code>01001000</code> = 72 = 'H')</li>\n<li><strong>ASCII filter</strong> — keep only printable characters (codes 32–126)</li>\n<li><strong>Regex search</strong> — scan for the <code>HACKDAY{...}</code> pattern in the extracted text</li>\n</ol>\n\n<h2>4 – Result</h2>\n<p>The script finds the flag embedded in the LSBs:</p>\n<pre><code>HACKDAY{M0N4_L1SA_IS_THE_NEW_META}</code></pre>\n<p><em>M0N4 L1SA</em> = \"Mona Lisa\" in leet speak — fitting for a challenge about hiding messages in plain sight.</p>\n\n<h2>LSB steganography explained</h2>\n<p>Why this works:</p>\n<ul>\n<li><strong>Minimal impact</strong> — changing the LSB of an audio sample alters its value by ±1, completely inaudible</li>\n<li><strong>High capacity</strong> — 1 bit per byte means a 1 MB file can hide 128 KB of data</li>\n<li><strong>Invisible</strong> — the file plays/looks/sounds normal</li>\n<li><strong>Easy to detect</strong> — if you know to look for it. Statistical analysis (chi-square test) or tools like <code>stegsolve</code> and <code>zsteg</code> can reveal LSB embedding</li>\n</ul>\n\n<h2>Key takeaways</h2>\n<ul>\n<li><strong>Challenge titles are hints</strong> — \"LSB\" in the title tells you exactly what technique to use</li>\n<li><strong>LSB extraction is trivial</strong> — a few lines of Python with bitwise AND</li>\n<li><strong>File extensions can lie</strong> — always check the actual file content, not just the name</li>\n<li><strong>Tools to know</strong>: <code>zsteg</code> (images), <code>stegsolve</code>, <code>binwalk</code>, or just Python for raw byte manipulation</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "steganography",
      "hackday",
      "LSB",
      "audio",
      "forensics"
    ],
    "hash": "sha512:d2f4a7c9e135",
    "mitigations": [
      "Use statistical analysis (chi-square tests) to detect LSB embedding in media files",
      "Apply file integrity monitoring to detect unauthorized modifications",
      "Be aware that file extensions can be misleading – always verify with magic bytes",
      "Tools like zsteg and stegsolve can automate LSB detection"
    ],
    "date": "2025-03-25T09:05:00Z"
  },
  {
    "id": "well-hidden-message",
    "title": "Well hidden message – Insignificant blue",
    "category": "system",
    "difficulty": "medium",
    "summary": "HackDay CTF – Video steganography: extracting LSB data from the blue channel of an AVI file's first 8 lines to reconstruct a hidden ZIP containing the flag.",
    "content": "<p>We're given a video file <code>well-hidden-message.avi</code> and the subtitle <em>\"Insignificant blue\"</em>. The challenge name hides three clues in plain sight.</p>\n\n<h2>1 – Decoding the title</h2>\n<p>Three keywords guide the entire solve:</p>\n<ul>\n<li><strong>\"Insignificant\"</strong> → LSB (Least Significant Bit)</li>\n<li><strong>\"Blue\"</strong> → the blue channel of each video frame (channel 0 in OpenCV's BGR format)</li>\n<li><strong>\"from the eighth line\"</strong> → extract data from lines 0 through 7 (the first 8 pixel rows)</li>\n</ul>\n<p>Technique: <strong>video LSB steganography on a specific color channel and specific pixel rows</strong>.</p>\n\n<h2>2 – First attempt: only the 8th line</h2>\n<p>Initial reading of \"eighth line\" → extract LSBs from line 7 only:</p>\n<pre><code>import cv2\n\ndef extract_lsb(video_path):\n    cap = cv2.VideoCapture(video_path)\n    lsb_values = []\n\n    while True:\n        ret, frame = cap.read()\n        if not ret:\n            break\n        line8 = frame[7, :, 0]   # 8th row, blue channel\n        lsb_values.extend(line8 &amp; 1)  # Extract LSB\n\n    # Convert bits to hex\n    hex_out = ''\n    for i in range(0, len(lsb_values), 4):\n        nibble = lsb_values[i:i+4]\n        hex_out += format(int(''.join(map(str, nibble)), 2), 'x')\n\n    return hex_out</code></pre>\n<p>The output contains fragments of a <strong>ZIP file header</strong> (<code>50 4B 03 04</code> = \"PK\") but the data is incomplete. We're on the right track but missing bytes.</p>\n\n<h2>3 – The fix: \"from\" the eighth line</h2>\n<p>Re-reading the challenge: the word <strong>\"from\"</strong> means all lines <strong>up to</strong> the eighth — lines 0 through 7.</p>\n<p>Updated extraction:</p>\n<pre><code># Replace single-line extraction with 8 lines\nfor j in range(8):\n    nth_line = frame[j, :, 0]       # Lines 0-7, blue channel\n    lsb_values.extend(nth_line &amp; 1) # Extract LSB from each</code></pre>\n<p>Now the output starts with a <strong>proper ZIP header</strong> and the file structure is intact.</p>\n\n<h2>4 – Full extraction script</h2>\n<pre><code>import cv2\n\ndef extract_lsb_from_video(video_path, output_file):\n    cap = cv2.VideoCapture(video_path)\n    lsb_values = []\n\n    while True:\n        ret, frame = cap.read()\n        if not ret:\n            break\n        for j in range(8):  # First 8 lines\n            line = frame[j, :, 0]  # Blue channel (BGR index 0)\n            lsb_values.extend(line &amp; 1)\n\n    # Convert to hex and write as binary\n    hex_str = ''\n    for i in range(0, len(lsb_values), 4):\n        nibble = lsb_values[i:i+4]\n        hex_str += format(int(''.join(map(str, nibble)), 2), 'x')\n\n    # Write hex as raw bytes\n    with open(output_file, 'wb') as f:\n        f.write(bytes.fromhex(hex_str))\n\nextract_lsb_from_video('well-hidden-message.avi', 'hidden.zip')</code></pre>\n\n<h2>5 – Extracting the ZIP</h2>\n<p>The output is a valid ZIP archive. Opening it with 7-Zip or <code>unzip</code> reveals:</p>\n<pre><code>hidden.zip\n└── flag.txt</code></pre>\n<p>Inside <code>flag.txt</code>:</p>\n<pre><code>HACKDAY{s73@M_$7@tion_4CcE5S}</code></pre>\n\n<h2>6 – Result</h2>\n<p>The flag:</p>\n<pre><code>HACKDAY{s73@M_$7@tion_4CcE5S}</code></pre>\n<p><em>s73@M $7@tion 4CcE5S</em> = \"Steam Station Access\" in leet speak.</p>\n\n<h2>How video LSB steganography works</h2>\n<p>This challenge combines multiple layers of specificity:</p>\n<ol>\n<li><strong>Video</strong> — each frame is an image, multiplying the data capacity</li>\n<li><strong>Blue channel only</strong> — one of the 3 color channels in BGR</li>\n<li><strong>First 8 rows only</strong> — limits the extraction region to a small slice of each frame</li>\n<li><strong>LSB</strong> — the least significant bit of each pixel value</li>\n</ol>\n<p>The extracted bits form a <strong>binary file</strong> (here, a ZIP archive). Each frame contributes a few hundred bits, and across all frames, enough data accumulates to store a complete file.</p>\n\n<h2>Key takeaways</h2>\n<ul>\n<li><strong>Read the challenge title carefully</strong> — every word is a clue (\"insignificant\" = LSB, \"blue\" = channel, \"eighth line\" = row range)</li>\n<li><strong>Watch for \"from\" vs \"at\"</strong> — \"from the 8th line\" means lines 0–7, not just line 7</li>\n<li><strong>Recognize file signatures</strong> — <code>50 4B 03 04</code> (PK) = ZIP header, validates you're on the right track</li>\n<li><strong>Video stego = image stego × frame count</strong> — each frame is an opportunity to hide data</li>\n<li><strong>OpenCV BGR order</strong> — in OpenCV, channel 0 is Blue, not Red (unlike PIL/RGB)</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "tags": [
      "steganography",
      "hackday",
      "LSB",
      "video",
      "forensics"
    ],
    "hash": "sha512:b8e3f1d6a427",
    "mitigations": [
      "Monitor for data hidden in specific color channels of video files",
      "Use statistical steganalysis to detect LSB embedding across video frames",
      "Validate file integrity with cryptographic hashes before processing",
      "Be aware that video steganography multiplies hiding capacity vs images"
    ],
    "date": "2025-03-25T09:09:00Z"
  }
]