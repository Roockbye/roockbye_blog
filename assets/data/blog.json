[
  {
    "id": "cognitive-reminder-call",
    "title": "Cognitive Reminder Call",
    "category": "research",
    "summary": "Challenge Crypto - PlatypwnCTF2025 writeup on breaking CRC32-based authentication and forging MACs using linear algebra over GF(2).",
    "content": "<h2>PlatypwnCTF2025 crypto/Cognitive Reminder Call</h2>\n<p>The server seems to be forgetful :(  Can you help it remember?</p>\n<h3>Files provided:</h3>\n<ul>\n<li>server.py</li>\n<li>Pipfile.lock</li>\n<li>Pipfile</li>\n<li>Dockerfile</li>\n</ul>\n<h3>1. What the server actually does</h3>\n<p>Internally, the server:</p>\n<ol>\n<li>Generates 4 random 16-byte chunks</li>\n<li>Derives an AES key from them using SHA256</li>\n<li>Encrypts the flag with AES-256-CBC</li>\n<li>Uses a secret <code>mac_key</code> and authenticates messages using <code>crc32(key + message)</code></li>\n<li>Then it 'forgets' the real key parts but gives us 4 CRC32 values</li>\n</ol>\n<h3>2. The Attack Strategy</h3>\n<p><strong>CRC32 is linear and totally not a secure MAC.</strong></p>\n<p>The vulnerability lies in the fact that <code>crc32(data, seed) = A_data * seed XOR c_data</code> where operations are over GF(2) (bitwise linear algebra).</p>\n<h4>Step 1: Recover crc32(mac_key)</h4>\n<p>From any authenticated message, we can recover the internal MAC state using Gaussian elimination over GF(2) on a 32x32 bit matrix. Once we have this state, we can forge valid MACs for any message.</p>\n<h4>Step 2: Build 4 blocks with target CRC32 values</h4>\n<p>Using the linearity of CRC32:</p>\n<ol>\n<li>Choose a random 12-byte prefix</li>\n<li>Let the last 4 bytes be an unknown 32-bit integer x</li>\n<li>Build matrix B showing how each bit of x affects the CRC</li>\n<li>Solve <code>B * x = target XOR F0</code> to get x</li>\n<li>Repeat for each of the 4 target CRC values</li>\n</ol>\n<h4>Step 3: Forge authentication and decrypt</h4>\n<p>With valid parts and forged MAC, we send our 'reminder' to the server, which re-encrypts the flag with our key and sends it back.</p>\n<h3>3. Why this is insecure</h3>\n<p>CRC32 is not cryptographic. Using <code>crc32(key || message)</code> as a MAC is completely broken because:</p>\n<ul>\n<li>It's a linear function - can be modeled as matrix multiplication</li>\n<li>With one authenticated message, you can recover the internal state after the key</li>\n<li>You can forge valid tags without knowing the key</li>\n<li>CRC32 is easy to invert on small messages - you can craft data with any CRC32 you want</li>\n</ul>\n<h3>Flag</h3>\n<p><code>PP{h4sh3s_4r3_m0r3_th4n_ch3cksums::9--CHRRGexlY}</code></p>\n<h3>Key Lessons</h3>\n<ul>\n<li>Never use checksums as cryptographic MACs</li>\n<li>CRC32 is fundamentally unsuitable for security purposes</li>\n<li>Linear functions over GF(2) are invertible and predictable</li>\n<li>Always use proven cryptographic primitives like HMAC or POLY1305</li>\n</ul>",
    "date": "2025-12-03T11:11:00Z",
    "tags": ["crypto", "platypwn2025", "CRC32", "MAC"]
  },
  {
    "id": "op-wraith",
    "title": "Operation Wraith: Tracking a Chinese APT's Infrastructure",
    "category": "redteam",
    "summary": "OSINT techniques used to map out C2 infrastructure, identify operators, and predict next-gen attack vectors.",
    "date": "2025-11-28T14:22:00Z",
    "tags": ["osint", "apt", "infrastructure"]
  },
  {
    "id": "hypervisor-deep",
    "title": "Deep Dive: The Complete Hypervisor Security Model",
    "category": "research",
    "summary": "Examining ring compression, VM exits, and the architectural boundaries that define modern virtualization security.",
    "date": "2025-11-20T10:55:00Z",
    "tags": ["hypervisor", "architecture", "security-model"]
  },
  {
    "id": "zero-day-economics",
    "title": "The Economics of Zero-Day Markets",
    "category": "blueprint",
    "summary": "Analysis of how zero-day pricing, broker networks, and nation-state demand shape the vulnerability economy.",
    "date": "2025-11-12T09:30:00Z",
    "tags": ["economics", "vulnerability", "markets"]
  },
  {
    "id": "rust-safety-escape",
    "title": "Escaping Rust's Safety Guarantees Through unsafe{}",
    "category": "research",
    "summary": "Common patterns where developers misuse unsafe blocks and practical exploitation techniques.",
    "date": "2025-11-05T15:18:00Z",
    "tags": ["rust", "unsafe", "memory-safety"]
  },
  {
    "id": "ai-adversarial-defense",
    "title": "AI Systems as Attack Surface: Adversarial Input Design",
    "category": "blueprint",
    "summary": "Methodology for crafting adversarial inputs against ML-based security systems and detection evasion.",
    "date": "2025-10-28T12:00:00Z",
    "tags": ["ai", "adversarial", "evasion"]
  },
  {
    "id": "supply-chain-backdoors",
    "title": "Supply Chain Attacks: From npm to Production",
    "category": "redteam",
    "summary": "Complete overview of typosquatting, dependency confusion, and maintainer impersonation attacks.",
    "date": "2025-10-15T08:45:00Z",
    "tags": ["supply-chain", "dependencies", "malware"]
  },
  {
    "id": "cmprw",
    "title": "C.M.P.R.W – GlacierCTF2025",
    "category": "research",
    "summary": "Breaking a pseudo-random rock-paper-scissors game by recovering a 64-bit LFSR state from partial observations via constraint-based DFS.",
    "content": "<h2>GlacierCTF2025 crypto/C.M.P.R.W</h2>\n<p>Some say that 75% of rock paper scissor matches end up in a tie. We suggest a more interesting one.</p>\n<p>This challenge looks like a fun little game at first: you pick one of five categories, the computer picks one too, and you win/lose based on a fixed set of rules.</p>\n<p>But the real goal is:</p>\n<p><strong>Beat the computer 200 times in a row.</strong></p>\n<p>And for the first 100 rounds, the game tells you how your choice compares to the computer's (win, lose, or tie). No punishment. Just \"free practice\".</p>\n<p>It's bait.<br>These 100 practice rounds are our way in.</p>\n\n<h2>1 – Understanding the game rules</h2>\n<p>You can choose one of these:</p>\n<pre><code>Welcome to C.M.P.R.W. If you win against the computer 200 time in a row.\nYou may claim our [SPECIAL] reward.\nHere, have some free trials as new-comer goodies.\nChoose one of 'crypto', 'misc', 'pwn', 'rev', 'web':</code></pre>\n<p>The computer also chooses one. Some choices beat others, similar to rock-paper-scissors.</p>\n<p>Imagine a circle: each category beats two others and loses to two others.</p>\n<p>So if we know what <em>the computer is going to choose</em>, we can always pick the winning option.</p>\n<p>This entire challenge becomes: <strong>Predict what the computer will choose next.</strong></p>\n\n<h2>2 – The computer is not actually random</h2>\n<p>Inside the challenge code, we find how the computer decides its choice.</p>\n<p>This is the key part:</p>\n<pre><code>choice = (state &amp; 0xf) % 5</code></pre>\n<p>Here's the idea:</p>\n<ul>\n<li>The computer keeps a <strong>big 64-bit number</strong> called <code>state</code>.</li>\n<li>To choose a move, it looks at the <strong>last 4 bits</strong> of this number.</li>\n<li>It turns that into one of the 5 categories.</li>\n<li>Then it updates the number using a fixed set of steps.</li>\n</ul>\n<p>This means: The computer is <strong>not</strong> using real randomness. It is using a predictable pattern.</p>\n<p>This pattern is called an <strong>LFSR</strong>, a simple type of pseudo-random number generator.</p>\n<p>The important part: If you know the state at any moment, you can know all future moves.</p>\n\n<h2>3 – The 100 practice rounds leak information</h2>\n<p>Every time we play, the server tells us:</p>\n<ul>\n<li>\"tie\" → the computer picked the same as us</li>\n<li>\"win\" → our choice beats the computer's</li>\n<li>\"lose\" → the computer's choice beats ours</li>\n</ul>\n<p>This gives us <strong>constraints</strong> on the value of:</p>\n<pre><code>(state_t &amp; 0xf) % 5</code></pre>\n<p>This doesn't reveal the nibble directly but it tells us which <strong>subset</strong> of 0–4 it must belong to.</p>\n<p>After 100 rounds, we have:</p>\n<ul>\n<li>100 constraints</li>\n<li>on 100 successive RNG states</li>\n</ul>\n<p>This is enough to reconstruct the <strong>initial 64-bit state</strong>.</p>\n\n<h2>4 – Recovering the Hidden RNG State</h2>\n<p>At this point, we know two things:</p>\n<ol>\n<li>The computer's choice each round is determined by <strong>the lowest nibble</strong> (4 bits) of a hidden 64-bit number (<code>state</code>).</li>\n<li>We collected <strong>100 rounds</strong> of feedback (\"win / lose / tie\"). These don't tell us the exact nibble, but they do tell us <strong>which nibble <em>mod 5</em></strong> the computer must have had.</li>\n</ol>\n<p>This means each round gives us a clue like:</p>\n<pre><code>(state_t &amp; 0xF) % 5 ∈ {some subset of 0..4}</code></pre>\n\n<h3>Breaking the 64-bit state into nibbles</h3>\n<p>A 64-bit number is simply:</p>\n<pre><code>N0 | N1 | N2 | ... | N15</code></pre>\n<p>where each Ni is a nibble (4 bits, value 0–15).</p>\n<p>So instead of solving for one giant number, we solve for <strong>16 tiny numbers</strong>, each between 0 and 15. This makes the search space manageable.</p>\n\n<h3>Phase 1: Direct narrowing (rounds 0–15)</h3>\n<p>During the <strong>first 16 rounds</strong>, the LFSR output nibble depends <strong>only on</strong> the nibble at the same position.</p>\n<p>Why? Because before the state gets mixed too much, each step of the LFSR shifts the state right, meaning:</p>\n<ul>\n<li>Round 0 output depends on N0</li>\n<li>Round 1 output depends on N1</li>\n<li>Round 2 output depends on N2</li>\n<li>…</li>\n<li>Round 15 output depends on N15</li>\n</ul>\n<p>Often, this shrinks each nibble's possibilities to <strong>2–4 values</strong> instead of 16.</p>\n\n<h3>Phase 2: Dependency tracking (rounds 16+)</h3>\n<p>After 16 rounds, each output nibble becomes a combination of <strong>several</strong> original nibbles. The script computes these dependencies in advance.</p>\n\n<h3>Phase 3: Depth-First Search</h3>\n<p>The script performs a <strong>depth-first search</strong> over the 16 nibbles. After each assignment, it checks all rounds where all dependencies are already known. If any output contradicts constraints → <strong>prune the branch</strong>.</p>\n<p>In practice, instead of checking 16⁶⁴ possibilities, you might only explore a few hundred valid partial states. This finishes in under a second.</p>\n\n<h3>Result</h3>\n<p>When the DFS reaches nibble 15 and all constraints match:</p>\n<ul>\n<li>The full 64-bit state has been successfully reconstructed</li>\n<li>Your local RNG is now perfectly in sync with the server</li>\n</ul>\n<p>The exploit wins all 200 rounds:</p>\n<pre><code>[+] Success! Won 200/200 rounds!\n[FLAG] gctf{y0u_4r3_7H3_TrUE_rN635u5_n0W_7rY_j3N5H1n_1Mp4C7}</code></pre>\n<p>Game over.</p>\n\n<p>By Roockbye</p>",
    "date": "2025-12-03T11:58:00Z",
    "tags": ["crypto", "glacierctf2025", "LFSR", "RNG"]
  },
  {
    "id": "tarsnap",
    "title": "Tarsnap \u2013 HeroCTF",
    "category": "research",
    "summary": "Compression side-channel attack (CRIME/BREACH style) on an encrypted TAR backup service \u2013 recovering a flag character by character via compressed size oracle.",
    "content": "<h2>HeroCTF crypto/Tarsnap</h2>\n<p>Why do encrypted ZIPs exist but not encrypted TARs? This challenge offers a \"super secure online encrypted tar archive service\" that lets you add the flag and your own files, then export the encrypted archive.</p>\n<p>The trick: ChaCha20 <strong>does not hide the size</strong> of the compressed data. And compression leaks information about the flag.</p>\n<p><strong>compression + encryption + attacker-controlled input = catastrophic leakage</strong></p>\n\n<h2>1 \u2013 How the server works</h2>\n<p>The server compresses flag + user data together with zlib, then encrypts with ChaCha20. Since ChaCha20 doesn't change the length, the encrypted output size reveals the compressed size.</p>\n\n<h2>2 \u2013 The compression side-channel</h2>\n<p>DEFLATE finds repeated patterns and replaces them with shorter references. If our input matches the flag prefix, compression shrinks more \u2192 smaller output. If wrong, compression finds fewer matches \u2192 bigger output.</p>\n<p>This is the same class of vulnerabilities as <strong>CRIME</strong>, <strong>BREACH</strong>, <strong>TIME</strong>, and <strong>HEIST</strong>.</p>\n\n<h2>3 \u2013 Amplification techniques</h2>\n<ul>\n<li><strong>800 repetitions</strong> with random salts to boost the compression signal</li>\n<li><strong>Multiple samples</strong> per guess to smooth noise</li>\n<li><strong>TOP_K re-testing</strong> to confirm the best candidate</li>\n</ul>\n\n<h2>4 \u2013 Result</h2>\n<p>The prefix grows character by character until the full flag is recovered:</p>\n<pre><code>Hero{5h0uld_h4v3_u53d_3ncryp7_7h3n_c0mpr355_1n5734d}</code></pre>\n\n<h3>Key Lessons</h3>\n<ul>\n<li>Never compress then encrypt user-controlled data alongside secrets</li>\n<li>Stream ciphers leak exact plaintext length through ciphertext length</li>\n<li>Add random padding before encryption to obscure compressed size</li>\n<li>CRIME/BREACH are real-world examples of this exact flaw</li>\n</ul>\n\n<p>By Roockbye</p>",
    "date": "2025-12-03T12:30:00Z",
    "tags": ["crypto", "heroctf", "compression", "side-channel", "CRIME"]
  },
  {
    "id": "mutlock",
    "title": "MuTLock – HTB Uni CTF 2024",
    "category": "research",
    "summary": "Reversing a timestamp-seeded multi-layer encryption (polyalphabetic + XOR) with dynamic key generation – brute-forcing a 1255-combination key space to recover the flag.",
    "content": "<h2>HTB Uni CTF 2024 crypto/MuTLock</h2>\n<p>The Frontier Board encrypts their secrets using a system tied to the ever-shifting cosmic cycles, woven with patterns that seem random to the untrained eye.</p>\n\n<h2>1 – Overview</h2>\n<p>We're given <strong>source.py</strong> (the encryption script) and <strong>output.txt</strong> (the encrypted flag). The script chains multiple weak ciphers with timestamp-based key selection.</p>\n\n<h2>2 – The encryption pipeline</h2>\n<p>The flag is <strong>split in half</strong>. Each half goes through:</p>\n<ol>\n<li><strong>Key generation</strong> – a deterministic PRNG key from a small seed</li>\n<li><strong>Polyalphabetic cipher</strong> – Vigenère-like, adding char values mod 256</li>\n<li><strong>Base64 encoding</strong></li>\n<li><strong>Single-byte XOR</strong></li>\n<li><strong>Hex encoding</strong></li>\n</ol>\n\n<h2>3 – Key selection via timestamp</h2>\n<pre><code>def get_timestamp_based_keys():\n    timestamp = int(time.time())\n    if timestamp % 2 == 0:\n        key_seed = random.randint(1, 1000)\n        xor_key = 42\n    else:\n        key_seed = 42\n        xor_key = random.randint(1, 255)\n    return key_seed, xor_key</code></pre>\n<p>Two paths depending on timestamp parity:</p>\n<ul>\n<li><strong>Even:</strong> random seed ∈ [1, 1000], fixed XOR = 42</li>\n<li><strong>Odd:</strong> fixed seed = 42, random XOR ∈ [1, 255]</li>\n</ul>\n<p>Total key space: <strong>1255 combinations</strong>. Trivially brute-forceable.</p>\n\n<h2>4 – Reversing the cipher</h2>\n<p>To decrypt: hex → XOR → base64 decode → subtract key chars mod 256.</p>\n<p>We test all 1255 combinations and filter for printable ASCII output.</p>\n<pre><code># Even path: 1000 seeds × fixed XOR=42\nfor seed in range(1, 1001):\n    key = generate_key(seed)\n    result = decrypt(hex_half, 42, key)\n    if is_printable(result): found!\n\n# Odd path: fixed seed=42 × 255 XOR keys\nfor xor_k in range(1, 256):\n    key = generate_key(42)\n    result = decrypt(hex_half, xor_k, key)\n    if is_printable(result): found!</code></pre>\n\n<h2>5 – Result</h2>\n<p>Decrypted flag:</p>\n<pre><code>HTB{timestamp_based_encryption_is_so_secure_i_promise}</code></pre>\n\n<h2>Why this is insecure</h2>\n<ul>\n<li><strong>Tiny key space</strong> – 1255 total combinations vs billions for real encryption</li>\n<li><strong>Deterministic PRNG</strong> – Python's <code>random</code> with known seed is fully predictable</li>\n<li><strong>Single-byte XOR</strong> – trivially reversible, adds zero security</li>\n<li><strong>Polyalphabetic cipher</strong> – a technique from the 16th century</li>\n<li><strong>Stacking weak ciphers ≠ strong encryption</strong></li>\n</ul>\n<p><strong>Lesson:</strong> Use modern authenticated encryption (AES-GCM, ChaCha20-Poly1305) instead of custom cipher stacks.</p>\n\n<p>Bye Roockbye</p>",
    "date": "2024-12-14T10:00:00Z",
    "tags": ["crypto", "htb-uni-2024", "polyalphabetic", "XOR", "brute-force"]
  },
  {
    "id": "drunk-christmas",
    "title": "Drunk Christmas – HackDay CTF",
    "category": "research",
    "summary": "Byte-by-byte flag recovery via chosen-plaintext attack on a file-sharing service that encrypts user input and the secret flag with the same keystream.",
    "content": "<h2>HackDay CTF crypto/Drunk Christmas</h2>\n<p>A \"secure file sharing\" service encrypts your uploaded file alongside the secret flag using the <strong>same keystream</strong>. Identical plaintext bytes produce identical ciphertext bytes — giving us a perfect oracle.</p>\n\n<h2>1 – The setup</h2>\n<p>Upload a file → server bundles it with <code>flag.txt</code> → encrypts both → returns the encrypted ZIP containing <code>input.txt.enc</code> and <code>flag.txt.enc</code>.</p>\n\n<h2>2 – The vulnerability</h2>\n<p>Both files share the same keystream:</p>\n<pre><code>input.txt.enc[i] = encrypt(input[i], keystream[i])\nflag.txt.enc[i]  = encrypt(flag[i],  keystream[i])</code></pre>\n<p>If <code>input[i] == flag[i]</code> → <code>input.txt.enc[i] == flag.txt.enc[i]</code>.</p>\n<p>This is a <strong>chosen-plaintext oracle</strong>: test any character at any position and instantly know if it's correct.</p>\n\n<h2>3 – Byte-by-byte recovery</h2>\n<p>Starting from <code>HACKDAY{</code>, for each unknown position:</p>\n<ol>\n<li>Try every printable character</li>\n<li>Upload <code>known_prefix + guess + padding</code></li>\n<li>Compare encrypted bytes at the target index</li>\n<li>Match → correct character found</li>\n</ol>\n<pre><code>for c in printable:\n    input_text = flag + c + \"A\" * (50 - len(flag) - 1)\n    # upload, download, extract\n    if input_enc[len(flag)] == flag_enc[len(flag)]:\n        flag += c\n        break</code></pre>\n\n<h2>4 – Result</h2>\n<pre><code>HACKDAY{Simple_Secrets_For_Weak_Cipher_1134567892}</code></pre>\n\n<h2>Why this is insecure</h2>\n<ul>\n<li><strong>Keystream reuse</strong> across multiple files enables direct comparison</li>\n<li><strong>Chosen-plaintext oracle</strong> – attacker controls one encrypted input</li>\n<li><strong>Deterministic encryption</strong> – same byte at same position = same ciphertext</li>\n</ul>\n<p><strong>Lesson:</strong> Never encrypt attacker-controlled data alongside secrets with the same keystream. Use unique nonces per file.</p>\n\n<p>Bye Roockbye</p>",
    "date": "2025-03-25T09:00:00Z",
    "tags": ["crypto", "hackday", "chosen-plaintext", "stream-cipher", "keystream-reuse"]
  },
  {
    "id": "edgar-loses-his-calm",
    "title": "Edgar loses his calm – HackDay CTF",
    "category": "redteam",
    "summary": "OSINT challenge: following a chain of public clues (architect → city → football club → player → Twitter handle) to compute an MD5 hash flag.",
    "content": "<h2>HackDay CTF OSINT/Edgar loses his calm</h2>\n<p>Edgar is furious about a football player. Our mission: identify who, find their Twitter handle, and compute the MD5 hash. Pure OSINT — no exploits, just research.</p>\n\n<h2>1 – The clue chain</h2>\n<p>The challenge gives us connected hints:</p>\n<ul>\n<li>Famous architect <strong>Renzo Piano</strong></li>\n<li>A <strong>football club</strong> in his <strong>hometown</strong></li>\n<li>A <strong>black player</strong> recently joined, <strong>targeted by racism</strong></li>\n<li>Find the player's <strong>Twitter handle</strong> → compute <strong>MD5 hash</strong></li>\n</ul>\n\n<h2>2 – Following the pivots</h2>\n<ol>\n<li><strong>Renzo Piano</strong> → born in <strong>Genoa, Italy</strong></li>\n<li><strong>Genoa</strong> → football club <strong>Genoa CFC</strong> (Serie A)</li>\n<li><strong>Genoa CFC + recent transfer + racism</strong> → <strong>Mario Balotelli</strong></li>\n<li><strong>Balotelli's Twitter</strong> → <code>@FinallyMario</code></li>\n</ol>\n\n<h2>3 – Computing the flag</h2>\n<pre><code>import hashlib\nhandle = \"@FinallyMario\"\nprint(hashlib.md5(handle.lower().encode()).hexdigest())\n# → 98d62c513ab6e0e7de0817613a360287</code></pre>\n\n<h2>4 – Result</h2>\n<pre><code>HACKDAY{98d62c513ab6e0e7de0817613a360287}</code></pre>\n\n<h2>Key takeaways</h2>\n<ul>\n<li><strong>OSINT = connecting dots</strong> — each clue narrows the search space</li>\n<li><strong>Cross-reference sources</strong>: Wikipedia, Transfermarkt, Twitter, news</li>\n<li><strong>Details matter</strong>: lowercase vs uppercase, with/without @ changes the hash</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "date": "2025-03-25T09:16:00Z",
    "tags": ["osint", "hackday", "social-media", "MD5", "reconnaissance"]
  },
  {
    "id": "find-eve-1",
    "title": "Find Eve 1 – HackDay CTF",
    "category": "research",
    "summary": "Two-layer decryption challenge: cracking AES-256-CBC with a Neuromancer-themed key, then decoding ASCII85 to reveal the hidden flag.",
    "content": "<h2>HackDay CTF crypto/Find Eve 1</h2>\n<p>A mysterious 208-byte file with no extension. Two layers of encoding stand between us and the flag.</p>\n\n<h2>1 – File analysis</h2>\n<ul>\n<li><strong>208 bytes</strong> = 13 × 16 → block cipher (AES)</li>\n<li><strong>High entropy</strong> → encrypted data</li>\n</ul>\n\n<h2>2 – Layer 1: AES-256-CBC</h2>\n<p>The key is <strong>Wintermute</strong> (AI from Gibson's <em>Neuromancer</em>). The salt: first 16 hex chars of SHA-256(\"Wintermute\") = <code>dfd05592762aa2ac</code>.</p>\n<pre><code>openssl enc -d -aes-256-cbc -salt -pbkdf2 \\\n  -S dfd05592762aa2ac \\\n  -in MessageSecret -out MessageDecrypt \\\n  -k Wintermute</code></pre>\n<p>Output: a strange-looking ASCII string — not plaintext yet.</p>\n\n<h2>3 – Layer 2: ASCII85 decoding</h2>\n<p>The decrypted text uses <strong>ASCII85</strong> (Base85, RFC 1924) encoding. Decoding it reveals:</p>\n<pre><code>Okay, I'll be there at 5 p.m.\nYes, I remember, you have to put a HACKDAY{r3D j@Ck37}...\nI have to leave you, we'll meet in front of the clock.</code></pre>\n\n<h2>4 – Result</h2>\n<pre><code>HACKDAY{r3D j@Ck37}</code></pre>\n\n<h2>Decryption chain</h2>\n<ol>\n<li>Encrypted file (208 bytes)</li>\n<li>↓ AES-256-CBC (key: Wintermute, salt: SHA256 prefix)</li>\n<li>ASCII85-encoded text</li>\n<li>↓ Base85 decode</li>\n<li>Plaintext + flag</li>\n</ol>\n\n<h2>Key takeaways</h2>\n<ul>\n<li>File size multiples of 16 → think AES block cipher</li>\n<li>Cultural references (Neuromancer) are common CTF password themes</li>\n<li>Always check if decrypted output is itself encoded</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "date": "2025-03-25T09:13:00Z",
    "tags": ["crypto", "hackday", "AES", "ASCII85", "multi-layer"]
  },
  {
    "id": "no-music-stego",
    "title": "It says a lot when there is no music – HackDay CTF",
    "category": "research",
    "summary": "Audio steganography: finding ASCII-encoded data hidden in the trailing silence of a WAV file — where no music plays, a message speaks.",
    "content": "<h2>HackDay CTF stego/It says a lot when there is no music</h2>\n<p>A suspicious WAV file. The title hints at the solution: the secret hides <strong>where there's silence</strong>.</p>\n\n<h2>1 – The hidden data</h2>\n<p>The file has 13.6M audio samples, followed by hundreds of zeros, then a burst of small non-zero values at the very end. These values are all in the <strong>printable ASCII range</strong> (32–125).</p>\n<pre><code>from scipy.io import wavfile\nrate, data = wavfile.read('suspicious_audio.wav')\ndata = data[13641006:]  # Skip to trailing region\n# Output: [0 0 0 ... 34 65 32 108 111 116 ...]</code></pre>\n\n<h2>2 – ASCII conversion</h2>\n<p>Converting sample values to characters:</p>\n<pre><code>message = ''.join(chr(v) for v in data if v != 0)\n# \"A lot when there is no music\".\n# Here is your flag : HACKDAY{Mast3r_0f_W4v(es)}</code></pre>\n\n<h2>3 – Result</h2>\n<pre><code>HACKDAY{Mast3r_0f_W4v(es)}</code></pre>\n\n<h2>How it works</h2>\n<p>ASCII character codes are embedded as <strong>raw sample values</strong> in the silent trailing region. Audio players ignore this silence. The values (34–125) are inaudible compared to normal audio amplitudes.</p>\n<p>Quick alternative: <code>strings -e b suspicious_audio.wav</code></p>\n\n<h2>Key takeaways</h2>\n<ul>\n<li>Check trailing silence in audio files for hidden data</li>\n<li>Plot waveforms to spot anomalies visually</li>\n<li>The challenge title is always a clue</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "date": "2025-03-25T09:10:00Z",
    "tags": ["steganography", "hackday", "audio", "WAV", "forensics"]
  },
  {
    "id": "mona-lsb",
    "title": "Mona LSB – HackDay CTF",
    "category": "research",
    "summary": "LSB steganography on a WAV file: extracting a hidden flag by reading the least significant bit of each byte and reconstructing ASCII text.",
    "content": "<h2>HackDay CTF stego/Mona LSB</h2>\n<p>The file <code>wmremona_is_you_here.wav</code> hides a message in its <strong>least significant bits</strong>. The title spells it out: LSB steganography.</p>\n\n<h2>1 – LSB extraction</h2>\n<p>For each byte in the file, extract bit 0 (<code>byte &amp; 1</code>). Group every 8 extracted bits into a new byte. Convert to ASCII.</p>\n<pre><code>import re\n\nwith open('wmremona_is_you_here.wav', 'rb') as f:\n    data = f.read()\n\n# Extract LSBs and reconstruct bytes\nlsb_bits = ''.join(str(b &amp; 1) for b in data)\nhidden = ''\nfor i in range(0, len(lsb_bits), 8):\n    byte = lsb_bits[i:i+8]\n    if len(byte) == 8:\n        c = chr(int(byte, 2))\n        if 32 &lt;= ord(c) &lt;= 126:\n            hidden += c\n\n# Find flag\nmatch = re.search(r'HACKDAY\\{.*?\\}', hidden)\nprint(match.group(0) if match else hidden[:500])</code></pre>\n\n<h2>2 – Result</h2>\n<pre><code>HACKDAY{M0N4_L1SA_IS_THE_NEW_META}</code></pre>\n\n<h2>Why LSB stego works</h2>\n<ul>\n<li>Changing the LSB alters a sample by ±1 — <strong>completely inaudible</strong></li>\n<li>1 bit per byte = a 1 MB file hides 128 KB of data</li>\n<li>Easy to detect with statistical analysis if you know to look</li>\n</ul>\n\n<h2>Key takeaways</h2>\n<ul>\n<li>Challenge titles are hints — \"LSB\" tells you the technique</li>\n<li>Extraction is trivial: bitwise AND + group into bytes</li>\n<li>File extensions can lie — always check actual content</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "date": "2025-03-25T09:05:00Z",
    "tags": ["steganography", "hackday", "LSB", "audio", "forensics"]
  },
  {
    "id": "well-hidden-message",
    "title": "Well hidden message – Insignificant blue – HackDay CTF",
    "category": "research",
    "summary": "Video steganography: extracting LSB data from the blue channel of an AVI's first 8 pixel rows to reconstruct a hidden ZIP archive containing the flag.",
    "content": "<h2>HackDay CTF stego/Well hidden message – Insignificant blue</h2>\n<p>An AVI video file and a title that's a triple hint: <strong>\"Insignificant\"</strong> = LSB, <strong>\"blue\"</strong> = blue channel, <strong>\"eighth line\"</strong> = first 8 pixel rows.</p>\n\n<h2>1 – The technique</h2>\n<p>For each video frame:</p>\n<ol>\n<li>Take the first 8 pixel rows</li>\n<li>Read the <strong>blue channel</strong> (BGR index 0 in OpenCV)</li>\n<li>Extract the <strong>LSB</strong> of each pixel value</li>\n</ol>\n<p>Accumulate across all frames → enough bits to reconstruct a binary file.</p>\n\n<h2>2 – First attempt vs fix</h2>\n<p>Initially extracted only line 7 → partial ZIP header visible but incomplete. Re-reading: \"<strong>from</strong> the eighth line\" = lines 0–7. Fixed extraction:</p>\n<pre><code>for j in range(8):\n    line = frame[j, :, 0]  # Blue channel, lines 0-7\n    lsb_values.extend(line &amp; 1)</code></pre>\n<p>Now the output is a valid ZIP file starting with <code>50 4B 03 04</code> (PK header).</p>\n\n<h2>3 – Result</h2>\n<p>The ZIP contains <code>flag.txt</code>:</p>\n<pre><code>HACKDAY{s73@M_$7@tion_4CcE5S}</code></pre>\n\n<h2>Key takeaways</h2>\n<ul>\n<li>Every word in the title is a clue: LSB, blue channel, line range</li>\n<li>Recognize file signatures: <code>50 4B 03 04</code> = ZIP</li>\n<li>Video stego = image stego × frame count</li>\n<li>OpenCV uses BGR order: channel 0 = Blue</li>\n</ul>\n\n<p>Bye Roockbye</p>",
    "date": "2025-03-25T09:09:00Z",
    "tags": ["steganography", "hackday", "LSB", "video", "forensics"]
  }
]
