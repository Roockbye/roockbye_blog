[
  {
    "id": "cognitive-reminder-call",
    "title": "Cognitive Reminder Call",
    "category": "crypto",
    "summary": "Challenge Crypto - PlatypwnCTF2025 writeup on breaking CRC32-based authentication and forging MACs using linear algebra over GF(2).",
    "content": "<h2>PlatypwnCTF2025 crypto/Cognitive Reminder Call</h2>\n<p>The server seems to be forgetful :(  Can you help it remember?</p>\n<h3>Files provided:</h3>\n<ul>\n<li>server.py</li>\n<li>Pipfile.lock</li>\n<li>Pipfile</li>\n<li>Dockerfile</li>\n</ul>\n<h3>1. What the server actually does</h3>\n<p>Internally, the server:</p>\n<ol>\n<li>Generates 4 random 16-byte chunks</li>\n<li>Derives an AES key from them using SHA256</li>\n<li>Encrypts the flag with AES-256-CBC</li>\n<li>Uses a secret <code>mac_key</code> and authenticates messages using <code>crc32(key + message)</code></li>\n<li>Then it 'forgets' the real key parts but gives us 4 CRC32 values</li>\n</ol>\n<h3>2. The Attack Strategy</h3>\n<p><strong>CRC32 is linear and totally not a secure MAC.</strong></p>\n<p>The vulnerability lies in the fact that <code>crc32(data, seed) = A_data * seed XOR c_data</code> where operations are over GF(2) (bitwise linear algebra).</p>\n<h4>Step 1: Recover crc32(mac_key)</h4>\n<p>From any authenticated message, we can recover the internal MAC state using Gaussian elimination over GF(2) on a 32x32 bit matrix. Once we have this state, we can forge valid MACs for any message.</p>\n<h4>Step 2: Build 4 blocks with target CRC32 values</h4>\n<p>Using the linearity of CRC32:</p>\n<ol>\n<li>Choose a random 12-byte prefix</li>\n<li>Let the last 4 bytes be an unknown 32-bit integer x</li>\n<li>Build matrix B showing how each bit of x affects the CRC</li>\n<li>Solve <code>B * x = target XOR F0</code> to get x</li>\n<li>Repeat for each of the 4 target CRC values</li>\n</ol>\n<h4>Step 3: Forge authentication and decrypt</h4>\n<p>With valid parts and forged MAC, we send our 'reminder' to the server, which re-encrypts the flag with our key and sends it back.</p>\n<h3>3. Why this is insecure</h3>\n<p>CRC32 is not cryptographic. Using <code>crc32(key || message)</code> as a MAC is completely broken because:</p>\n<ul>\n<li>It's a linear function - can be modeled as matrix multiplication</li>\n<li>With one authenticated message, you can recover the internal state after the key</li>\n<li>You can forge valid tags without knowing the key</li>\n<li>CRC32 is easy to invert on small messages - you can craft data with any CRC32 you want</li>\n</ul>\n<h3>Flag</h3>\n<p><code>PP{h4sh3s_4r3_m0r3_th4n_ch3cksums::9--CHRRGexlY}</code></p>\n<h3>Key Lessons</h3>\n<ul>\n<li>Never use checksums as cryptographic MACs</li>\n<li>CRC32 is fundamentally unsuitable for security purposes</li>\n<li>Linear functions over GF(2) are invertible and predictable</li>\n<li>Always use proven cryptographic primitives like HMAC or POLY1305</li>\n</ul>",
    "date": "2025-12-03T11:11:00Z",
    "tags": ["crypto", "platypwn2025", "CRC32", "MAC"]
  },
  {
    "id": "op-wraith",
    "title": "Operation Wraith: Tracking a Chinese APT's Infrastructure",
    "category": "redteam",
    "summary": "OSINT techniques used to map out C2 infrastructure, identify operators, and predict next-gen attack vectors.",
    "date": "2025-11-28T14:22:00Z",
    "tags": ["osint", "apt", "infrastructure"]
  },
  {
    "id": "hypervisor-deep",
    "title": "Deep Dive: The Complete Hypervisor Security Model",
    "category": "research",
    "summary": "Examining ring compression, VM exits, and the architectural boundaries that define modern virtualization security.",
    "date": "2025-11-20T10:55:00Z",
    "tags": ["hypervisor", "architecture", "security-model"]
  },
  {
    "id": "zero-day-economics",
    "title": "The Economics of Zero-Day Markets",
    "category": "blueprint",
    "summary": "Analysis of how zero-day pricing, broker networks, and nation-state demand shape the vulnerability economy.",
    "date": "2025-11-12T09:30:00Z",
    "tags": ["economics", "vulnerability", "markets"]
  },
  {
    "id": "rust-safety-escape",
    "title": "Escaping Rust's Safety Guarantees Through unsafe{}",
    "category": "research",
    "summary": "Common patterns where developers misuse unsafe blocks and practical exploitation techniques.",
    "date": "2025-11-05T15:18:00Z",
    "tags": ["rust", "unsafe", "memory-safety"]
  },
  {
    "id": "ai-adversarial-defense",
    "title": "AI Systems as Attack Surface: Adversarial Input Design",
    "category": "blueprint",
    "summary": "Methodology for crafting adversarial inputs against ML-based security systems and detection evasion.",
    "date": "2025-10-28T12:00:00Z",
    "tags": ["ai", "adversarial", "evasion"]
  },
  {
    "id": "supply-chain-backdoors",
    "title": "Supply Chain Attacks: From npm to Production",
    "category": "redteam",
    "summary": "Complete overview of typosquatting, dependency confusion, and maintainer impersonation attacks.",
    "date": "2025-10-15T08:45:00Z",
    "tags": ["supply-chain", "dependencies", "malware"]
  }
]
