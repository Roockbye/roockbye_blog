[
  {
    "id": "cognitive-reminder-call",
    "title": "Cognitive Reminder Call",
    "category": "research",
    "summary": "Challenge Crypto - PlatypwnCTF2025 writeup on breaking CRC32-based authentication and forging MACs using linear algebra over GF(2).",
    "content": "<h2>PlatypwnCTF2025 crypto/Cognitive Reminder Call</h2>\n<p>The server seems to be forgetful :(  Can you help it remember?</p>\n<h3>Files provided:</h3>\n<ul>\n<li>server.py</li>\n<li>Pipfile.lock</li>\n<li>Pipfile</li>\n<li>Dockerfile</li>\n</ul>\n<h3>1. What the server actually does</h3>\n<p>Internally, the server:</p>\n<ol>\n<li>Generates 4 random 16-byte chunks</li>\n<li>Derives an AES key from them using SHA256</li>\n<li>Encrypts the flag with AES-256-CBC</li>\n<li>Uses a secret <code>mac_key</code> and authenticates messages using <code>crc32(key + message)</code></li>\n<li>Then it 'forgets' the real key parts but gives us 4 CRC32 values</li>\n</ol>\n<h3>2. The Attack Strategy</h3>\n<p><strong>CRC32 is linear and totally not a secure MAC.</strong></p>\n<p>The vulnerability lies in the fact that <code>crc32(data, seed) = A_data * seed XOR c_data</code> where operations are over GF(2) (bitwise linear algebra).</p>\n<h4>Step 1: Recover crc32(mac_key)</h4>\n<p>From any authenticated message, we can recover the internal MAC state using Gaussian elimination over GF(2) on a 32x32 bit matrix. Once we have this state, we can forge valid MACs for any message.</p>\n<h4>Step 2: Build 4 blocks with target CRC32 values</h4>\n<p>Using the linearity of CRC32:</p>\n<ol>\n<li>Choose a random 12-byte prefix</li>\n<li>Let the last 4 bytes be an unknown 32-bit integer x</li>\n<li>Build matrix B showing how each bit of x affects the CRC</li>\n<li>Solve <code>B * x = target XOR F0</code> to get x</li>\n<li>Repeat for each of the 4 target CRC values</li>\n</ol>\n<h4>Step 3: Forge authentication and decrypt</h4>\n<p>With valid parts and forged MAC, we send our 'reminder' to the server, which re-encrypts the flag with our key and sends it back.</p>\n<h3>3. Why this is insecure</h3>\n<p>CRC32 is not cryptographic. Using <code>crc32(key || message)</code> as a MAC is completely broken because:</p>\n<ul>\n<li>It's a linear function - can be modeled as matrix multiplication</li>\n<li>With one authenticated message, you can recover the internal state after the key</li>\n<li>You can forge valid tags without knowing the key</li>\n<li>CRC32 is easy to invert on small messages - you can craft data with any CRC32 you want</li>\n</ul>\n<h3>Flag</h3>\n<p><code>PP{h4sh3s_4r3_m0r3_th4n_ch3cksums::9--CHRRGexlY}</code></p>\n<h3>Key Lessons</h3>\n<ul>\n<li>Never use checksums as cryptographic MACs</li>\n<li>CRC32 is fundamentally unsuitable for security purposes</li>\n<li>Linear functions over GF(2) are invertible and predictable</li>\n<li>Always use proven cryptographic primitives like HMAC or POLY1305</li>\n</ul>",
    "date": "2025-12-03T11:11:00Z",
    "tags": ["crypto", "platypwn2025", "CRC32", "MAC"]
  },
  {
    "id": "op-wraith",
    "title": "Operation Wraith: Tracking a Chinese APT's Infrastructure",
    "category": "redteam",
    "summary": "OSINT techniques used to map out C2 infrastructure, identify operators, and predict next-gen attack vectors.",
    "date": "2025-11-28T14:22:00Z",
    "tags": ["osint", "apt", "infrastructure"]
  },
  {
    "id": "hypervisor-deep",
    "title": "Deep Dive: The Complete Hypervisor Security Model",
    "category": "research",
    "summary": "Examining ring compression, VM exits, and the architectural boundaries that define modern virtualization security.",
    "date": "2025-11-20T10:55:00Z",
    "tags": ["hypervisor", "architecture", "security-model"]
  },
  {
    "id": "zero-day-economics",
    "title": "The Economics of Zero-Day Markets",
    "category": "blueprint",
    "summary": "Analysis of how zero-day pricing, broker networks, and nation-state demand shape the vulnerability economy.",
    "date": "2025-11-12T09:30:00Z",
    "tags": ["economics", "vulnerability", "markets"]
  },
  {
    "id": "rust-safety-escape",
    "title": "Escaping Rust's Safety Guarantees Through unsafe{}",
    "category": "research",
    "summary": "Common patterns where developers misuse unsafe blocks and practical exploitation techniques.",
    "date": "2025-11-05T15:18:00Z",
    "tags": ["rust", "unsafe", "memory-safety"]
  },
  {
    "id": "ai-adversarial-defense",
    "title": "AI Systems as Attack Surface: Adversarial Input Design",
    "category": "blueprint",
    "summary": "Methodology for crafting adversarial inputs against ML-based security systems and detection evasion.",
    "date": "2025-10-28T12:00:00Z",
    "tags": ["ai", "adversarial", "evasion"]
  },
  {
    "id": "supply-chain-backdoors",
    "title": "Supply Chain Attacks: From npm to Production",
    "category": "redteam",
    "summary": "Complete overview of typosquatting, dependency confusion, and maintainer impersonation attacks.",
    "date": "2025-10-15T08:45:00Z",
    "tags": ["supply-chain", "dependencies", "malware"]
  },
  {
    "id": "cmprw",
    "title": "C.M.P.R.W – GlacierCTF2025",
    "category": "research",
    "summary": "Breaking a pseudo-random rock-paper-scissors game by recovering a 64-bit LFSR state from partial observations via constraint-based DFS.",
    "content": "<h2>GlacierCTF2025 crypto/C.M.P.R.W</h2>\n<p>Some say that 75% of rock paper scissor matches end up in a tie. We suggest a more interesting one.</p>\n<p>This challenge looks like a fun little game at first: you pick one of five categories, the computer picks one too, and you win/lose based on a fixed set of rules.</p>\n<p>But the real goal is:</p>\n<p><strong>Beat the computer 200 times in a row.</strong></p>\n<p>And for the first 100 rounds, the game tells you how your choice compares to the computer's (win, lose, or tie). No punishment. Just \"free practice\".</p>\n<p>It's bait.<br>These 100 practice rounds are our way in.</p>\n\n<h2>1 – Understanding the game rules</h2>\n<p>You can choose one of these:</p>\n<pre><code>Welcome to C.M.P.R.W. If you win against the computer 200 time in a row.\nYou may claim our [SPECIAL] reward.\nHere, have some free trials as new-comer goodies.\nChoose one of 'crypto', 'misc', 'pwn', 'rev', 'web':</code></pre>\n<p>The computer also chooses one. Some choices beat others, similar to rock-paper-scissors.</p>\n<p>Imagine a circle: each category beats two others and loses to two others.</p>\n<p>So if we know what <em>the computer is going to choose</em>, we can always pick the winning option.</p>\n<p>This entire challenge becomes: <strong>Predict what the computer will choose next.</strong></p>\n\n<h2>2 – The computer is not actually random</h2>\n<p>Inside the challenge code, we find how the computer decides its choice.</p>\n<p>This is the key part:</p>\n<pre><code>choice = (state &amp; 0xf) % 5</code></pre>\n<p>Here's the idea:</p>\n<ul>\n<li>The computer keeps a <strong>big 64-bit number</strong> called <code>state</code>.</li>\n<li>To choose a move, it looks at the <strong>last 4 bits</strong> of this number.</li>\n<li>It turns that into one of the 5 categories.</li>\n<li>Then it updates the number using a fixed set of steps.</li>\n</ul>\n<p>This means: The computer is <strong>not</strong> using real randomness. It is using a predictable pattern.</p>\n<p>This pattern is called an <strong>LFSR</strong>, a simple type of pseudo-random number generator.</p>\n<p>The important part: If you know the state at any moment, you can know all future moves.</p>\n\n<h2>3 – The 100 practice rounds leak information</h2>\n<p>Every time we play, the server tells us:</p>\n<ul>\n<li>\"tie\" → the computer picked the same as us</li>\n<li>\"win\" → our choice beats the computer's</li>\n<li>\"lose\" → the computer's choice beats ours</li>\n</ul>\n<p>This gives us <strong>constraints</strong> on the value of:</p>\n<pre><code>(state_t &amp; 0xf) % 5</code></pre>\n<p>This doesn't reveal the nibble directly but it tells us which <strong>subset</strong> of 0–4 it must belong to.</p>\n<p>After 100 rounds, we have:</p>\n<ul>\n<li>100 constraints</li>\n<li>on 100 successive RNG states</li>\n</ul>\n<p>This is enough to reconstruct the <strong>initial 64-bit state</strong>.</p>\n\n<h2>4 – Recovering the Hidden RNG State</h2>\n<p>At this point, we know two things:</p>\n<ol>\n<li>The computer's choice each round is determined by <strong>the lowest nibble</strong> (4 bits) of a hidden 64-bit number (<code>state</code>).</li>\n<li>We collected <strong>100 rounds</strong> of feedback (\"win / lose / tie\"). These don't tell us the exact nibble, but they do tell us <strong>which nibble <em>mod 5</em></strong> the computer must have had.</li>\n</ol>\n<p>This means each round gives us a clue like:</p>\n<pre><code>(state_t &amp; 0xF) % 5 ∈ {some subset of 0..4}</code></pre>\n\n<h3>Breaking the 64-bit state into nibbles</h3>\n<p>A 64-bit number is simply:</p>\n<pre><code>N0 | N1 | N2 | ... | N15</code></pre>\n<p>where each Ni is a nibble (4 bits, value 0–15).</p>\n<p>So instead of solving for one giant number, we solve for <strong>16 tiny numbers</strong>, each between 0 and 15. This makes the search space manageable.</p>\n\n<h3>Phase 1: Direct narrowing (rounds 0–15)</h3>\n<p>During the <strong>first 16 rounds</strong>, the LFSR output nibble depends <strong>only on</strong> the nibble at the same position.</p>\n<p>Why? Because before the state gets mixed too much, each step of the LFSR shifts the state right, meaning:</p>\n<ul>\n<li>Round 0 output depends on N0</li>\n<li>Round 1 output depends on N1</li>\n<li>Round 2 output depends on N2</li>\n<li>…</li>\n<li>Round 15 output depends on N15</li>\n</ul>\n<p>Often, this shrinks each nibble's possibilities to <strong>2–4 values</strong> instead of 16.</p>\n\n<h3>Phase 2: Dependency tracking (rounds 16+)</h3>\n<p>After 16 rounds, each output nibble becomes a combination of <strong>several</strong> original nibbles. The script computes these dependencies in advance.</p>\n\n<h3>Phase 3: Depth-First Search</h3>\n<p>The script performs a <strong>depth-first search</strong> over the 16 nibbles. After each assignment, it checks all rounds where all dependencies are already known. If any output contradicts constraints → <strong>prune the branch</strong>.</p>\n<p>In practice, instead of checking 16⁶⁴ possibilities, you might only explore a few hundred valid partial states. This finishes in under a second.</p>\n\n<h3>Result</h3>\n<p>When the DFS reaches nibble 15 and all constraints match:</p>\n<ul>\n<li>The full 64-bit state has been successfully reconstructed</li>\n<li>Your local RNG is now perfectly in sync with the server</li>\n</ul>\n<p>The exploit wins all 200 rounds:</p>\n<pre><code>[+] Success! Won 200/200 rounds!\n[FLAG] gctf{y0u_4r3_7H3_TrUE_rN635u5_n0W_7rY_j3N5H1n_1Mp4C7}</code></pre>\n<p>Game over.</p>\n\n<p>By Roockbye</p>",
    "date": "2025-12-03T11:58:00Z",
    "tags": ["crypto", "glacierctf2025", "LFSR", "RNG"]
  },
  {
    "id": "tarsnap",
    "title": "Tarsnap \u2013 HeroCTF",
    "category": "research",
    "summary": "Compression side-channel attack (CRIME/BREACH style) on an encrypted TAR backup service \u2013 recovering a flag character by character via compressed size oracle.",
    "content": "<h2>HeroCTF crypto/Tarsnap</h2>\n<p>Why do encrypted ZIPs exist but not encrypted TARs? This challenge offers a \"super secure online encrypted tar archive service\" that lets you add the flag and your own files, then export the encrypted archive.</p>\n<p>The trick: ChaCha20 <strong>does not hide the size</strong> of the compressed data. And compression leaks information about the flag.</p>\n<p><strong>compression + encryption + attacker-controlled input = catastrophic leakage</strong></p>\n\n<h2>1 \u2013 How the server works</h2>\n<p>The server compresses flag + user data together with zlib, then encrypts with ChaCha20. Since ChaCha20 doesn't change the length, the encrypted output size reveals the compressed size.</p>\n\n<h2>2 \u2013 The compression side-channel</h2>\n<p>DEFLATE finds repeated patterns and replaces them with shorter references. If our input matches the flag prefix, compression shrinks more \u2192 smaller output. If wrong, compression finds fewer matches \u2192 bigger output.</p>\n<p>This is the same class of vulnerabilities as <strong>CRIME</strong>, <strong>BREACH</strong>, <strong>TIME</strong>, and <strong>HEIST</strong>.</p>\n\n<h2>3 \u2013 Amplification techniques</h2>\n<ul>\n<li><strong>800 repetitions</strong> with random salts to boost the compression signal</li>\n<li><strong>Multiple samples</strong> per guess to smooth noise</li>\n<li><strong>TOP_K re-testing</strong> to confirm the best candidate</li>\n</ul>\n\n<h2>4 \u2013 Result</h2>\n<p>The prefix grows character by character until the full flag is recovered:</p>\n<pre><code>Hero{5h0uld_h4v3_u53d_3ncryp7_7h3n_c0mpr355_1n5734d}</code></pre>\n\n<h3>Key Lessons</h3>\n<ul>\n<li>Never compress then encrypt user-controlled data alongside secrets</li>\n<li>Stream ciphers leak exact plaintext length through ciphertext length</li>\n<li>Add random padding before encryption to obscure compressed size</li>\n<li>CRIME/BREACH are real-world examples of this exact flaw</li>\n</ul>\n\n<p>By Roockbye</p>",
    "date": "2025-12-03T12:30:00Z",
    "tags": ["crypto", "heroctf", "compression", "side-channel", "CRIME"]
  }
]
